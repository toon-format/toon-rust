File: addressing.rs
===================
/* src/addressing/addressing.rs */
//!▫~•◦-------------------------------‣
//! # Weyl Semantic Addressing System for deterministic intent-based addressing.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Deterministic Address Generation:** Creates stable 8-head addresses from textual intents using SHA-256 hashing.
//! - **Coordinate-based Addressing:** Supports creation of addresses from numeric coordinates with base-240 mapping.
//! - **Similarity Matching:** Provides head-matching functionality for semantic similarity analysis.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `slot` and `store`.
//! Address structures adhere to the semantic addressing pipeline and are compatible
//! with the system's serialization and persistence layers.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::{WeylSemanticAddress};
//!
//! let address = WeylSemanticAddress::from_text_intent("find similar documents").unwrap();
//! let key = address.to_key();
//! let other_address = WeylSemanticAddress::from_text_intent("related docs").unwrap();
//! let matches = address.matches(&other_address);
//!
//! // The 'address' can now be used for storage and retrieval operations.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use yoshi::error::Result;

/// WeylSemanticAddress: deterministic 8-head address derived from SHA-256 of intent.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct WeylSemanticAddress {
    pub heads: [u8; 8],
    pub digest: [u8; 32],
    pub context: Option<String>,
}

impl WeylSemanticAddress {
    /// Create a Weyl address deterministically from a textual intent.
    pub fn from_text_intent(intent: &str) -> Result<Self> {
        let normalized = intent.trim().to_lowercase();
        let mut hasher = Sha256::new();
        hasher.update(normalized.as_bytes());
        let digest = hasher.finalize();
        let mut d32 = [0u8; 32];
        d32.copy_from_slice(&digest[..32]);
        let mut heads = [0u8; 8];
        for i in 0..8 {
            heads[i] = (d32[i] % 240) as u8; // base-240 mapping
        }
        Ok(Self {
            heads,
            digest: d32,
            context: None,
        })
    }

    /// Create address from numeric coordinates (E8 vector or similar), optional rounding.
    pub fn from_coords(coords: &[f32; 8]) -> Result<Self> {
        // simple deterministic mapping: scale and quantize
        let mut d32 = [0u8; 32];
        // fill digest by copying little-endian f32 bytes
        for (i, f) in coords.iter().enumerate().take(8) {
            let bytes = f.to_le_bytes();
            d32[i * 4..i * 4 + 4].copy_from_slice(&bytes);
        }
        // fallback to sha of the bytes for stability
        let mut hasher = Sha256::new();
        hasher.update(&d32);
        let h = hasher.finalize();
        let mut digest = [0u8; 32];
        digest.copy_from_slice(&h[..32]);
        let mut heads = [0u8; 8];
        for i in 0..8 {
            heads[i] = (digest[i] % 240) as u8;
        }
        Ok(Self {
            heads,
            digest,
            context: None,
        })
    }

    /// Stable string key for storage
    pub fn to_key(&self) -> String {
        self.heads
            .iter()
            .map(|h| h.to_string())
            .collect::<Vec<_>>()
            .join(",")
    }

    /// Count matching heads with another address
    pub fn matches(&self, other: &Self) -> usize {
        self.heads
            .iter()
            .zip(other.heads.iter())
            .filter(|(a, b)| a == b)
            .count()
    }
}

File: builtins.rs
=================
/* src/builtins/builtins.rs */
//!▫~•◦-------------------------------‣
//! # Built-in ASV (Address-Slot-Value) Operations for Rune-GSV integration.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Slot Storage:** Provides ASV storage operations with automatic slot creation and validation.
//! - **Slot Retrieval:** Enables intent-based slot retrieval with JSON serialization support.
//! - **Similarity Querying:** Offers k-nearest-neighbor query functionality for semantic similarity search.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `slot` and `store`.
//! Built-in functions adhere to the hydron evaluator interface and return JSON-compatible results.
//! Result structures are compatible with the system's serialization pipeline.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::{asv_store, asv_get, asv_query, QuantizedContinuum};
//!
//! let mut store = QuantizedContinuum::default();
//! let bundle = serde_json::json!({ "payload": {"note": "test"} });
//! let key = asv_store(&mut store, "find documents", bundle).unwrap();
//! let retrieved = asv_get(&store, "find documents").unwrap();
//! let similar = asv_query(&store, "find documents", 5).unwrap();
//!
//! // The results can be used for further processing in the evaluator.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use crate::slot::{ExecutionTrace, RankingData, SGLRuneSlot, SemanticGraph};
use crate::store::QuantizedContinuum;
use serde_json::Value;
use yoshi::error::Result;

/// Built-in public API that integrates with hydron evaluator.
/// These functions are sync and return JSON-like results to the evaluator.

pub fn asv_store(store: &mut QuantizedContinuum, intent: &str, bundle: Value) -> Result<String> {
    // Try to convert incoming bundle into SGLRuneSlot; if missing fields, fallback to minimal slot
    let slot: SGLRuneSlot = match serde_json::from_value(bundle.clone()) {
        Ok(s) => s,
        Err(_) => {
            // fallback: build a minimal slot using provided payload and intent
            let address: Vec<u8> = Vec::new();
            let created_at = 0.0f64;
            let semantic_graph = SemanticGraph {
                nodes: Vec::new(),
                frames: Vec::new(),
            };
            let execution = ExecutionTrace {
                id: String::new(),
                effect_set_id: None,
                steps: Vec::new(),
            };
            let ranking = RankingData {
                query_id: String::new(),
                text: String::new(),
                candidate_ids: Vec::new(),
                elo_scores: std::collections::HashMap::new(),
            };
            let payload_val = bundle
                .get("payload")
                .cloned()
                .unwrap_or(serde_json::Value::Null);
            SGLRuneSlot {
                address,
                intent: intent.to_string(),
                created_at,
                semantic_graph,
                execution,
                ranking,
                payload: payload_val,
            }
        }
    };
    slot.address.len(); // ensure vector present
    let key = store.store(intent, slot)?;
    Ok(key)
}

pub fn asv_get(store: &QuantizedContinuum, intent: &str) -> Result<Option<Value>> {
    if let Some(slot) = store.retrieve(intent) {
        let v = serde_json::to_value(slot)?;
        Ok(Some(v))
    } else {
        Ok(None)
    }
}

pub fn asv_query(store: &QuantizedContinuum, intent: &str, k: usize) -> Result<Value> {
    let results = store.query_similar_intents(intent, k);
    let v = serde_json::to_value(results)?;
    Ok(v)
}

File: query.rs
==============
/* src/query/query.rs */
//!▫~•◦-------------------------------‣
//! # Semantic Query Utilities for head-based similarity matching.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Head Matching:** Provides utility functions for counting matching heads between addresses and slots.
//! - **Similarity Analysis:** Enables semantic similarity comparison using Weyl address heads.
//! - **Query Support:** Offers foundational functions for similarity-based retrieval operations.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `addressing` and `slot`.
//! Query functions adhere to the semantic addressing pattern and are compatible
//! with the system's similarity search pipeline.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::{count_head_matches, WeylSemanticAddress, SGLRuneSlot};
//!
//! let address = WeylSemanticAddress::from_text_intent("query").unwrap();
//! let slot = SGLRuneSlot::default();
//! let matches = count_head_matches(&address, &slot);
//!
//! // The match count can be used for similarity ranking.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use crate::addressing::WeylSemanticAddress;
use crate::slot::SGLRuneSlot;

pub fn count_head_matches(a: &WeylSemanticAddress, b: &SGLRuneSlot) -> usize {
    let bh: [u8; 8] = b.address.clone().try_into().unwrap_or([0u8; 8]);
    let wb = WeylSemanticAddress {
        heads: bh,
        digest: [0u8; 32],
        context: None,
    };
    a.matches(&wb)
}

File: persistence.rs
====================
/* src/persistence/persistence.rs */
//!▫~•◦-------------------------------‣
//! # Atomic Persistence Layer for Rune-GSV slot storage and retrieval.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Atomic File Operations:** Provides safe write operations using temporary files with atomic renames.
//! - **Graceful File Reading:** Handles missing or empty files gracefully with appropriate fallbacks.
//! - **JSON Serialization:** Supports serialization and deserialization of slot collections.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `slot` and `store`.
//! Persistence operations adhere to the atomic write pattern for crash safety.
//! Result structures are compatible with the system's serialization pipeline.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::{write_rune_atomic, read_rune, SGLRuneSlot};
//!
//! let slots = vec![SGLRuneSlot::default(), SGLRuneSlot::default()];
//! write_rune_atomic("data.rune", &slots).unwrap();
//! let loaded_slots = read_rune("data.rune").unwrap();
//!
//! // The slots are now persisted and can be reloaded.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use crate::slot::SGLRuneSlot;
use std::fs;
use std::path::Path;
use yoshi::Context;
use yoshi::error::Result;

/// Save to disk atomically: write tmp then rename.
pub fn write_rune_atomic<P: AsRef<Path>>(path: P, slots: &[SGLRuneSlot]) -> Result<()> {
    let p = path.as_ref();
    if let Some(parent) = p.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create dir {}", parent.display()))?;
    }

    let tmp = p.with_extension("tmp");
    let json = serde_json::to_string_pretty(&slots).context("Serialize slots to JSON")?;
    fs::write(&tmp, json.as_bytes())
        .with_context(|| format!("Write tmp file {}", tmp.display()))?;
    fs::rename(&tmp, p).with_context(|| format!("Rename tmp to {}", p.display()))?;
    Ok(())
}

/// Read file gracefully; returns empty vec when missing or empty
pub fn read_rune<P: AsRef<Path>>(path: P) -> Result<Vec<SGLRuneSlot>> {
    let p = path.as_ref();
    if !p.exists() {
        return Ok(vec![]);
    }
    let raw = fs::read_to_string(p).with_context(|| format!("Read file {}", p.display()))?;
    if raw.trim().is_empty() {
        return Ok(vec![]);
    }
    let slots: Vec<SGLRuneSlot> = serde_json::from_str(&raw).context("Deserialize slots JSON")?;
    Ok(slots)
}

File: slot.rs
=============
/* src/slot/slot.rs */
//!▫~•◦-------------------------------‣
//! # Semantic Graph Language Rune Slot Data Structures
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Graph Data Structures:** Provides Node, Frame, and SemanticGraph structures for knowledge representation.
//! - **Execution Tracing:** Supports tracking of execution traces with step-by-step operation recording.
//! - **Ranking Data:** Includes structures for query-based ranking with ELO scoring support.
//! - **Slot Management:** Offers the core SGLRuneSlot structure with address-based storage and flexible payload support.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `addressing` and `store`.
//! Slot structures adhere to the semantic addressing pattern and are compatible
//! with the system's serialization and persistence layers.
//! The payload field supports dynamic JSON data for extensibility.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::{SGLRuneSlot, SemanticGraph, Node, Frame};
//!
//! let mut slot = SGLRuneSlot::default();
//! slot.intent = "example intent".to_string();
//! slot.semantic_graph.nodes.push(Node {
//!     id: "node1".to_string(),
//!     kind: "concept".to_string(),
//!     label: "Example Concept".to_string(),
//!     types: vec!["Type1".to_string()],
//!     meta: std::collections::HashMap::new(),
//! });
//!
//! let json_value = slot.to_map();
//! // The slot can now be stored, retrieved, and processed.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Node {
    pub id: String,
    pub kind: String,
    pub label: String,
    pub types: Vec<String>,
    #[serde(default)]
    pub meta: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Frame {
    pub id: String,
    pub concept_id: String,
    pub roles: HashMap<String, Vec<String>>,
    pub scope: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SemanticGraph {
    pub nodes: Vec<Node>,
    pub frames: Vec<Frame>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ExecutionTrace {
    pub id: String,
    pub effect_set_id: Option<String>,
    pub steps: Vec<HashMap<String, String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RankingData {
    pub query_id: String,
    pub text: String,
    pub candidate_ids: Vec<String>,
    pub elo_scores: HashMap<String, f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SGLRuneSlot {
    pub address: Vec<u8>,
    pub intent: String,
    pub created_at: f64,

    #[serde(default)]
    pub semantic_graph: SemanticGraph,
    #[serde(default)]
    pub execution: ExecutionTrace,
    #[serde(default)]
    pub ranking: RankingData,
    /// Free-form payload for dynamic / plugin-driven data; optional and can hold any JSON-compatible info.
    #[serde(default = "serde_json::Value::default")]
    pub payload: serde_json::Value,
}

impl SGLRuneSlot {
    pub fn to_map(&self) -> serde_json::Value {
        serde_json::json!({
            "address_heads": self.address,
            "intent": self.intent,
            "created_at": self.created_at,
            "semantic_graph": self.semantic_graph,
            "execution": self.execution,
            "ranking": self.ranking,
            "payload": self.payload,
        })
    }
}

File: store.rs
==============
/* src/store/store.rs */
//!▫~•◦-------------------------------‣
//! # Quantized Continuum: Thread-safe Semantic Slot Storage Engine
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Thread-safe Storage:** Provides concurrent access to slot collections using Arc<RwLock>.
//! - **Intent-based Retrieval:** Supports storage and retrieval of slots using semantic intent addresses.
//! - **Similarity Querying:** Offers k-nearest-neighbor search based on head-matching similarity.
//! - **Persistent Storage:** Includes automatic hydration from and persistence to disk storage.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `addressing`, `slot`, and `persistence`.
//! The QuantizedContinuum structure uses multiple indexes (intent_index, head_buckets) for efficient querying.
//! Storage operations are atomic and thread-safe, supporting concurrent access patterns.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::{QuantizedContinuum, SGLRuneSlot};
//!
//! let mut store = QuantizedContinuum::default();
//! let slot = SGLRuneSlot {
//!     intent: "find documents".to_string(),
//!     ..Default::default()
//! };
//! let key = store.store("find documents", slot).unwrap();
//! let retrieved = store.retrieve("find documents");
//! let similar = store.query_similar_intents("find documents", 5);
//!
//! // The store provides efficient semantic storage and retrieval.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use crate::addressing::WeylSemanticAddress;
use crate::persistence;
use crate::slot::SGLRuneSlot;
use dirs;
use once_cell::sync::Lazy;
use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::sync::{Arc, RwLock};
use std::time::{SystemTime, UNIX_EPOCH};
use yoshi::error::Result;

#[derive(Debug, Clone)]
pub struct QuantizedContinuum {
    pub storage_path: String,
    pub vault_name: String,
    pub slots: Arc<RwLock<HashMap<String, SGLRuneSlot>>>,
    /// normalized_intent -> key
    pub intent_index: Arc<RwLock<HashMap<String, String>>>,
    /// head buckets: head (0..239) -> keys
    pub head_buckets: Arc<RwLock<HashMap<u8, HashSet<String>>>>,
}

impl QuantizedContinuum {
    /// default constructor using `$HOME/.rasv/gsv.rune` vault
    pub fn default() -> Self {
        Self::with_name("gsv")
    }

    /// create a continuation that uses a named vault in the user's home .rasv directory
    pub fn with_name(vault_name: impl Into<String>) -> Self {
        let vn = vault_name.into();
        let mut path = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
        path.push(".rasv");
        let fname = format!("{}.rune", vn);
        path.push(fname);
        Self::new(path.to_string_lossy().to_string(), vn)
    }

    /// create using explicit storage path and vault name
    pub fn new(storage_path: impl Into<String>, vault_name: impl Into<String>) -> Self {
        let path = storage_path.into();
        let vn = vault_name.into();
        let slots = Arc::new(RwLock::new(HashMap::new()));
        let intent_index = Arc::new(RwLock::new(HashMap::new()));
        let head_buckets = Arc::new(RwLock::new(HashMap::new()));
        let qc = Self {
            storage_path: path,
            vault_name: vn,
            slots,
            intent_index,
            head_buckets,
        };
        // hydrate cache from disk at startup
        if let Ok(vec) = persistence::read_rune(&qc.storage_path) {
            let mut map = qc.slots.write().unwrap();
            let mut iidx = qc.intent_index.write().unwrap();
            let mut buckets = qc.head_buckets.write().unwrap();
            for s in vec {
                let key = s
                    .address
                    .iter()
                    .map(|b| b.to_string())
                    .collect::<Vec<_>>()
                    .join(",");
                if !s.intent.is_empty() {
                    iidx.insert(normalize_intent(&s.intent), key.clone());
                }
                for h in &s.address {
                    buckets.entry(*h).or_default().insert(key.clone());
                }
                map.insert(key, s);
            }
        }
        qc
    }

    fn now_ts() -> f64 {
        let dur = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        dur.as_secs_f64()
    }

    pub fn storage_path_for_name(vault_name: &str) -> String {
        let mut path = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
        path.push(".rasv");
        let fname = format!("{}.rune", vault_name);
        path.push(fname);
        path.to_string_lossy().to_string()
    }

    /// Store a slot under a given intent; compute address if missing.
    pub fn store(&mut self, intent: &str, mut bundle: SGLRuneSlot) -> Result<String> {
        if bundle.created_at == 0.0 {
            bundle.created_at = Self::now_ts();
        }
        // compute address from intent if missing/empty
        if bundle.address.len() != 8 {
            let wa = WeylSemanticAddress::from_text_intent(intent)?;
            bundle.address = wa.heads.to_vec();
        }
        let key = slugify_addrs(&bundle.address);
        self.slots
            .write()
            .unwrap()
            .insert(key.clone(), bundle.clone());
        // update indices
        if !bundle.intent.is_empty() {
            self.intent_index
                .write()
                .unwrap()
                .insert(normalize_intent(&bundle.intent), key.clone());
        }
        for h in &bundle.address {
            self.head_buckets
                .write()
                .unwrap()
                .entry(*h)
                .or_default()
                .insert(key.clone());
        }
        // persist to disk
        let all: Vec<SGLRuneSlot> = self.slots.read().unwrap().values().cloned().collect();
        persistence::write_rune_atomic(&self.storage_path, &all)?;
        Ok(key)
    }

    /// Retrieve a specific slot by intent - tries a normalized intent map first
    pub fn retrieve(&self, intent: &str) -> Option<SGLRuneSlot> {
        let normalized = normalize_intent(intent);
        if let Some(key) = self.intent_index.read().unwrap().get(&normalized) {
            return self.slots.read().unwrap().get(key).cloned();
        }
        let addr = WeylSemanticAddress::from_text_intent(intent).ok()?;
        let key = slugify_addrs(&addr.heads.to_vec());
        self.slots.read().unwrap().get(&key).cloned()
    }

    /// Query similar intents using head buckets for candidate selection
    pub fn query_similar_intents(&self, intent: &str, k: usize) -> Vec<SGLRuneSlot> {
        let addr = WeylSemanticAddress::from_text_intent(intent).unwrap();
        let mut candidates: HashSet<String> = HashSet::new();
        {
            let buckets = self.head_buckets.read().unwrap();
            for h in &addr.heads {
                if let Some(keys) = buckets.get(h) {
                    for key in keys {
                        candidates.insert(key.clone());
                    }
                }
            }
        }
        let mut hints: Vec<(usize, SGLRuneSlot)> = Vec::new();
        for key in candidates.iter() {
            if let Some(s) = self.slots.read().unwrap().get(key) {
                let sa_heads: [u8; 8] = s.address.clone().try_into().unwrap_or([0u8; 8]);
                let sa = WeylSemanticAddress {
                    heads: sa_heads,
                    digest: [0u8; 32],
                    context: None,
                };
                let score = addr.matches(&sa);
                if score > 0 {
                    hints.push((score, s.clone()));
                }
            }
        }
        hints.sort_by(|a, b| b.0.cmp(&a.0));
        hints.into_iter().take(k).map(|(_, s)| s).collect()
    }
}

static DEFAULT_STORE: Lazy<RwLock<QuantizedContinuum>> =
    Lazy::new(|| RwLock::new(QuantizedContinuum::default()));

/// Return a reference to the global default continuum store (lazily initialized)
pub fn default_store() -> &'static RwLock<QuantizedContinuum> {
    &DEFAULT_STORE
}

fn slugify_addrs(a: &Vec<u8>) -> String {
    a.iter()
        .map(|b| b.to_string())
        .collect::<Vec<_>>()
        .join(",")
}

fn normalize_intent(s: &str) -> String {
    s.trim().to_lowercase()
}

File: lib.rs
============
/* src/lib.rs */
//!▫~•◦-------------------------------‣
//! # Rune-GSV: Graph Semantic Value Storage System
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gsv to achieve efficient graph-based data storage and querying system.
//!
//! ### Key Capabilities
//! - **Modular Architecture:** Provides core modules for addressing, slot management, storage, and querying.
//! - **Public API:** Exposes key data structures and functionality for external integration.
//! - **Prelude Support:** Offers convenient import of commonly used types and functions.
//!
//! ### Architectural Notes
//! This module serves as the main entry point for the rune-gsv crate.
//! It integrates with modules such as `addressing`, `slot`, `store`, `query`, `persistence`, and `builtins`.
//! The prelude module provides ergonomic access to core functionality.
//!
//! ### Example
//! ```rust
//! use crate::rune_gsv::prelude::*;
//!
//! let address = WeylSemanticAddress::from_text_intent("example").unwrap();
//! let mut store = QuantizedContinuum::default();
//! let slot = SGLRuneSlot::default();
//!
//! // Core types are now available for use.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

pub mod addressing;
pub mod builtins;
pub mod persistence;
pub mod query;
pub mod slot;
pub mod store;

pub use crate::addressing::WeylSemanticAddress;
pub use crate::slot::{ExecutionTrace, RankingData, SGLRuneSlot, SemanticGraph};
pub use crate::slot::{Node, Frame};
pub use crate::store::QuantizedContinuum;
pub use crate::persistence::{write_rune_atomic, read_rune};
pub use crate::builtins::{asv_store, asv_get, asv_query};
pub use crate::query::count_head_matches;

pub mod prelude {
    pub use crate::{QuantizedContinuum, SGLRuneSlot, WeylSemanticAddress};
}
