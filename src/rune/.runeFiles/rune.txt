File: grammar.pest
==================
WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" }

COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

// --- LEXICAL PRIMITIVES ---
ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" )* }

// Semantic prefix: single uppercase letter followed by colon (A:, T:, V:, R:, etc.)
semantic_prefix = @{ ASCII_ALPHA_UPPER ~ ":" }

// Semantic identifier: prefix + name (e.g., T:Gf8, V:vector, R:continuum)
semantic_ident = { semantic_prefix ~ ident }

number = @{
    "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)?   // simple int/float
}

string = @{
    "\"" ~ string_inner ~ "\""
}

string_inner = @{
    (
        !("\"" | "\\") ~ ANY
        | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    )*
}

// Boolean literals: B:t (true) or B:f (false)
boolean_literal = { "B:" ~ ("t" | "f") }

// --- OPERATORS (matched in order of length) ---

// 1. Glyph operators (must be ordered longest-first, now included in relation_op for chaining)
// Note: glyph_op removed from grammar, integrated into relation_op for better parsing of chains

// 2. Flow operators (lower precedence - flow between things)
flow_op = {
      "<->"    // FlowBidirectional
    | ">-<"    // FlowConvergent
    | "->"     // FlowRight
    | "<-"     // FlowLeft
}

// 3. Structural / binding operators (higher precedence - create associations)
struct_op = {
      "\\|/"   // SymmetricSplit
    | "/|\\"   // BranchAnchorBranch
    | "/\\"    // SplitJoin
    | "\\/"    // JoinSplit
    | "|/"     // AnchorDescend
    | "/|"     // BranchStabilize
    | "\\|"    // RootStabilize
    | "|\\"    // StabilizeRoot
    | "::"     // Namespace
    | ":="     // Define
    | ":>"     // Output
    | "<:"     // Input
    | "|>"     // PipelineRight
    | "<|"     // PipelineLeft
    | "<="     // LessEqual
    | ">="     // GreaterEqual
    | "||"     // Parallel
    | ":"      // Bind
    | "="      // Equal
    | "<"      // Less
    | ">"      // Greater
    | "\\"     // Ancestor
    | "|"      // Alias
    | "~"      // Transform
}

// All relation operators combined (for fallback parsing)
relation_op = { flow_op | struct_op }

// Path operators used for hierarchical access (distinct from math)
path_op = { "/" | "\\" }

// Unified operator token (arithmetic operators only within math blocks `[]`)
op = { relation_op }

// --- EXPRESSIONS ---
// Domains: Structural (outside []) vs Arithmetic (inside [])

// Function call: name(arg1, arg2, ...)
fn_call = { ident ~ "(" ~ relation_expr ~ ("," ~ relation_expr)* ~ ")" }

// Array literal: [1,2,3] or [a,b,c] (comma-separated)
// Distinct from math blocks which use operators without commas
array_literal = { "[" ~ relation_expr ~ ("," ~ relation_expr)+ ~ "]" }

term = {
      string
    | number
    | boolean_literal // Boolean literals: B:t, B:f
    | math_block      // Try math block first (has operators/unary)
    | fn_call         // Try function call (has parens)
    | array_literal   // Then try array (has commas)
    | semantic_ident
    | ident
    | "(" ~ relation_expr ~ ")"
}

// Arithmetic within [ ... ] value blocks ---
// Math precedence: PEMDAS (Parentheses, Exponents, Multiply/Divide, Add/Subtract)
math_block  = { "[" ~ math_expr ~ "]" }

math_expr   = { math_add }

math_add    = { math_mul ~ (WHITESPACE* ~ math_add_op ~ WHITESPACE* ~ math_mul)* }
math_add_op = { "+" | "-" }

math_mul    = { math_exp ~ (WHITESPACE* ~ math_mul_op ~ WHITESPACE* ~ math_exp)* }
math_mul_op = { "*" | "/" | "%" }

math_exp    = { math_unary ~ (WHITESPACE* ~ math_exp_op ~ WHITESPACE* ~ math_unary)* }
math_exp_op = { "^" | "√" | "R" }

math_unary  = { math_unary_op? ~ math_atom }
math_unary_op = { "-" | "+" }

// Math atom now supports arrays and semantic identifiers inside math blocks
math_array_literal = { "[" ~ math_expr ~ ("," ~ math_expr)+ ~ "]" }
math_atom   = { number | semantic_ident | math_array_literal | ident | "(" ~ math_expr ~ ")" }

// Structural expressions ---
// Precedence layers: flow_expr < struct_expr < access < term
// Lower precedence (parsed first) = looser binding

// Access (hierarchical navigation - using binary operators below)
access = { term ~ (WHITESPACE* ~ path_op ~ WHITESPACE* ~ term)* }

// Structural operators (tighter binding - associations, definitions)
struct_expr = { access ~ (WHITESPACE* ~ struct_op ~ WHITESPACE* ~ access)* }

// Flow operators (looser binding - data flow between structures)
flow_expr = { struct_expr ~ (WHITESPACE* ~ flow_op ~ WHITESPACE* ~ struct_expr)* }

// Relations: top-level expression (kept for backward compatibility)
relation_expr = { flow_expr }

// Expression: structural operations only (no arithmetic)
expr = { relation_expr }

// --- STATEMENTS ---

// Root declaration (supports namespaces like e8::continuum)
root_decl = { "root:" ~ WHITESPACE* ~ ident ~ ("::" ~ ident)* }

// TOON block (indentation-based)
// Use $ to disable implicit whitespace, @ for atomic capture
toon_content = @{
    (
        // Match any line that isn't empty and doesn't start a new top-level statement
        (!NEWLINE ~ ANY)+ ~ NEWLINE
    )+
}

toon_block = ${
    ident ~ " "* ~ "~TOON:" ~ NEWLINE ~
    toon_content
}

// Kernel archetype declarations
kernel_param = { ident ~ ":" ~ WHITESPACE* ~ (number | ident | string) }
kernel_archetype = { "CUDA:Archetype:" ~ ident ~ "(" ~ (kernel_param ~ ("," ~ WHITESPACE* ~ kernel_param)*)? ~ ")" }
kernel_decl = { semantic_ident ~ WHITESPACE* ~ ":=" ~ WHITESPACE* ~ kernel_archetype }

// Expression statement (catch-all for operator expressions)
stmt_expr = { relation_expr }

// Top-level statement
stmt = _{ root_decl | toon_block | kernel_decl | stmt_expr }

// File: sequence of statements
// Note: No WHITESPACE* before stmt to preserve TOON block indentation
file = { SOI ~ (NEWLINE* ~ stmt ~ WHITESPACE* ~ NEWLINE*)* ~ EOI }


File: mod.rs
============
/* src/rune/hydron/mod.rs */
//! RUNE (Root-Unified Notation Encoding) is a semantic extension built on top of TOON.
//! Where TOON provides token-efficient data serialization, RUNE adds:
//!
//! - **Root-oriented semantics**: Everything revolves around hierarchical roots
//! - **Operator calculus**: Glyphs and tokens for describing relationships, flow, and structure
//! - **E8-awareness**: Geometric and identity-aware operators
//! - **Composability**: Mix RUNE semantics with TOON data blocks seamlessly
//!
//! ## Overview
//!
//! RUNE files can contain:
//! - **TOON blocks**: Raw TOON data (preserved verbatim)
//! - **RUNE operators**: Relations, constraints, transformations over TOON data
//! - **Root declarations**: Anchor points in your E8 ecosystem
//!
//! ## Example RUNE File
//! ```rune
//! root: continuum
//!
//! data ~TOON:
//!   users[3]{id,name,role}:
//!     1,Ada,admin
//!     2,Bob,user
//!     3,Eve,viewer
//!
//! # RUNE semantics over TOON data
//! users / 0 -> role := admin
//! users / * -> name ~ ValidString()
//! ```
//!
//! This crate leverages the TOON format as foundational data representation
//! while adding symbolic operator layers for E8 ecosystems.
//!
//! TOKEN_FORMAT is Copyright (c) 2025-PRESENT Shreyas S Bhat, Johann Schopplich
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

mod ast;
mod ops;
mod parser;
pub mod parts;

#[cfg(feature = "hydron")]
pub mod hydron;

pub use ast::*;
pub use ops::*;
pub use parser::*;

// Re-export common types for convenience
pub type RuneParser = parser::ParseError;

/// Parse a RUNE source string into a list of statements.
pub fn parse_rune(input: &str) -> Result<Vec<Stmt>, ParseError> {
    parser::parse(input)
}

/// Encode TOON data blocks within RUNE files as raw strings.
pub fn encode_rune(statements: &[Stmt]) -> String {
    let mut output = String::new();
    for stmt in statements {
        output.push_str(&format!("{}\n", stmt));
    }
    output
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_toon_block() {
        let input = r#"
root: test_root

data ~TOON:
  items[2]{id,name}:
    1,hello
    2,world
"#;
        let stmts = parse_rune(input).unwrap();
        assert_eq!(stmts.len(), 2);
        // First statement is root declaration
        if let Stmt::RootDecl(root) = &stmts[0] {
            assert_eq!(root.0.as_str(), "test_root");
        } else {
            panic!("Expected root declaration");
        }
        // Second is TOON block
        if let Stmt::ToonBlock { name, content } = &stmts[1] {
            assert_eq!(name.0.as_str(), "data");
            assert!(content.contains("items[2]"));
        } else {
            panic!("Expected TOON block");
        }
    }

    #[test]
    fn test_operator_expression() {
        let input = r#"
items / 0 -> name := hello
"#;
        let stmts = parse_rune(input).unwrap();
        assert_eq!(stmts.len(), 1);
        if let Stmt::Expr(expr) = &stmts[0] {
            // Check it's a binary expression with -> operator (lower precedence)
            // Parses as: items / 0 -> (name := hello)
            if let Expr::Binary { op, left, right } = expr {
                assert_eq!(*op, RuneOp::FlowRight);
                assert_eq!(format!("{}", left), "items / 0");
                assert_eq!(format!("{}", right), "name := hello");
            } else {
                panic!("Expected binary expression");
            }
        }
    }
}

File: parser.rs
===============
/* src/rune/parser.rs */
//!
//! # e8 Notation – RUNE Parser
//!▫~•◦-------------------------‣
//!
//! This module provides parsing functionality for RUNE source code,
//! converting text into `Stmt` structures with proper operator precedence.
//! It uses Pest for lexical analysis and implements expression parsing
//! driven by the grammar’s precedence layering.
//!
//! The parser handles:
//! - **Operator precedence** via grammar layers:
//!   - `mul`   → `*` level
//!   - `add_sub` → `+` / `-`
//!   - `access` / `relation_expr` / `expr` → structural / relation ops
//! - **TOON blocks**: Raw content preservation for later TOON library parsing
//! - **Root declarations**: Semantic anchors for E8 contexts
//! - **Expression trees**: Recursive binary structures respecting precedence
//!
//! ### Implementation Details
//! - Uses grammar-encoded precedence (`term (op term)*` per layer).
//! - Preserves TOON blocks as raw strings without internal parsing.
//! - Validates all operators against the closed `RuneOp` registry.
//!
//! ### Error Handling
//! Parser errors include:
//! - Invalid operators (not in registry)
//! - Mismatched parentheses
//! - Malformed TOON blocks
//! - Unexpected tokens
//!
//! ### Example
//! ```rust
//! use rune_format::rune::parse_rune;
//!
//! let input = r#"
//! root: continuum
//! data ~TOON:
//!   users[2]{id,name}:
//!     1,Ada
//!     2,Bob
//! users / 1 := Bob
//! "#;
//!
//! let stmts = parse_rune(input).unwrap();
//! // stmts contains RootDecl, ToonBlock, and ExprStmt
//! ```
//!
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use pest::Parser;
use pest::iterators::Pair;
use pest_derive::Parser;
use std::str::FromStr;
use thiserror::Error;

use crate::rune::ast::*;
use crate::rune::ops::*;

// Pest grammar reference
#[derive(Parser)]
#[grammar = "rune/grammar.pest"]
pub struct RuneParser;

/// Root error type for parsing RUNE source code.
#[derive(Debug, Error)]
pub enum ParseError {
    #[error("Pest parse error: {0}")]
    Pest(Box<pest::error::Error<Rule>>),
    #[error("Invalid operator '{0}' not in registry")]
    InvalidOperator(String),
    #[error("Expected identifier, found: {0}")]
    ExpectedIdent(String),
    #[error("Expected number, found: {0}")]
    ExpectedNumber(String),
    #[error("Parse tree error: {0}")]
    ParseTree(String),
}

/// Parse RUNE source code into a list of statements.
pub fn parse(input: &str) -> Result<Vec<Stmt>, ParseError> {
    let pairs = RuneParser::parse(Rule::file, input).map_err(|e| ParseError::Pest(Box::new(e)))?;
    let mut stmts = Vec::new();

    for pair in pairs {
        if pair.as_rule() == Rule::file {
            for inner_pair in pair.into_inner() {
                match inner_pair.as_rule() {
                    Rule::WHITESPACE | Rule::COMMENT => {} // skip
                    Rule::stmt => {
                        if let Some(stmt_pair) = inner_pair.into_inner().next() {
                            stmts.push(parse_stmt(stmt_pair)?);
                        }
                    }
                    Rule::root_decl | Rule::toon_block | Rule::stmt_expr => {
                        stmts.push(parse_stmt(inner_pair)?);
                    }
                    _ => {}
                }
            }
        }
    }

    Ok(stmts)
}

/// Parse and return typed statements using a shallow type inference pass.
pub fn parse_typed(input: &str) -> Result<Vec<crate::rune::ast::StmtTyped>, ParseError> {
    let stmts = parse(input)?;
    let mut typed: Vec<crate::rune::ast::StmtTyped> = Vec::new();
    for stmt in stmts {
        match stmt {
            crate::rune::ast::Stmt::RootDecl(id) => {
                typed.push(crate::rune::ast::StmtTyped::root(id.to_string()))
            }
            crate::rune::ast::Stmt::ToonBlock { name, content } => typed.push(
                crate::rune::ast::StmtTyped::toon_block(name.to_string(), content),
            ),
            crate::rune::ast::Stmt::KernelDecl { name, archetype } => {
                typed.push(crate::rune::ast::StmtTyped::KernelDecl {
                    name: name.clone(),
                    archetype: archetype.clone(),
                });
            }
            crate::rune::ast::Stmt::Expr(expr) => {
                let te = crate::rune::ast::TypedExpr::infer(&expr);
                typed.push(crate::rune::ast::StmtTyped::expr(te));
            }
        }
    }
    Ok(typed)
}

/// Parse a statement pair into a Stmt.
fn parse_stmt(pair: Pair<Rule>) -> Result<Stmt, ParseError> {
    let rule = pair.as_rule();
    match rule {
        Rule::root_decl => parse_root_decl(pair),
        Rule::toon_block => parse_toon_block(pair),
        Rule::kernel_decl => parse_kernel_decl(pair),
        Rule::stmt_expr => {
            let expr_pair = pair.into_inner().next().unwrap();
            Ok(Stmt::expr(parse_expr(expr_pair)?))
        }
        _ => Err(ParseError::ParseTree(format!(
            "Unexpected statement rule: {:?}",
            rule
        ))),
    }
}

/// Parse root declaration: `root: name` or `root: e8::continuum`
fn parse_root_decl(pair: Pair<Rule>) -> Result<Stmt, ParseError> {
    let inner = pair.into_inner();

    let mut segments = Vec::new();

    // Collect all identifier segments (with :: separators)
    for pair in inner {
        if pair.as_rule() == Rule::ident {
            segments.push(pair.as_str());
        }
    }

    if segments.is_empty() {
        return Err(ParseError::ParseTree(
            "root declaration missing identifier".to_string(),
        ));
    }

    // Join segments with :: to create the full name
    let name = segments.join("::");
    Ok(Stmt::root(&name))
}

/// Parse TOON block: `name ~TOON:\n  content\n  content`
fn parse_toon_block(pair: Pair<Rule>) -> Result<Stmt, ParseError> {
    let mut inner = pair.into_inner();
    let ident_pair = inner.next().unwrap();
    let name = ident_pair.as_str();

    // The next pair is toon_content (atomic capture of all lines)
    let content_pair = inner.next().unwrap();
    let content = content_pair.as_str();

    // Split into lines and dedent (remove common leading whitespace)
    let lines: Vec<&str> = content.lines().collect();

    if lines.is_empty() {
        return Ok(Stmt::toon_block(name, String::new()));
    }

    // Find minimum indentation (excluding empty lines)
    let min_indent = lines
        .iter()
        .filter(|line| !line.trim().is_empty())
        .map(|line| line.len() - line.trim_start().len())
        .min()
        .unwrap_or(0);

    // Remove the common indentation from all lines
    let dedented: Vec<String> = lines
        .iter()
        .map(|line| {
            if line.trim().is_empty() {
                String::new()
            } else {
                line[min_indent..].to_string()
            }
        })
        .collect();

    let final_content = dedented.join("\n");

    Ok(Stmt::toon_block(name, final_content))
}

/// Parse kernel parameter: ident : (number | ident | string)
fn parse_kernel_param(pair: Pair<Rule>) -> Result<(Ident, Literal), ParseError> {
    let mut inner = pair.into_inner();
    let name_pair = inner.next().unwrap();
    let name = Ident::new(name_pair.as_str());

    inner.next(); // :
    inner.next(); // WHITESPACE*

    let value_pair = inner.next().unwrap();
    let value = match value_pair.as_rule() {
        Rule::number => {
            let num = value_pair
                .as_str()
                .parse()
                .map_err(|_| ParseError::ExpectedNumber(value_pair.as_str().to_string()))?;
            Literal::Number(num)
        }
        Rule::string => {
            let raw = value_pair.as_str();
            let content = &raw[1..raw.len() - 1];
            let unescaped = content
                .replace("\\\"", "\"")
                .replace("\\\\", "\\")
                .replace("\\n", "\n")
                .replace("\\r", "\r")
                .replace("\\t", "\t");
            Literal::String(unescaped)
        }
        Rule::ident => Literal::String(value_pair.as_str().to_string()),
        _ => {
            return Err(ParseError::ParseTree(format!(
                "Unexpected value type in kernel param: {:?}",
                value_pair.as_rule()
            )));
        }
    };

    Ok((name, value))
}

/// Parse kernel archetype: CUDA:Archetype:ident(params...)
fn parse_kernel_archetype(pair: Pair<Rule>) -> Result<KernelArchetype, ParseError> {
    let mut inner = pair.into_inner();
    inner.next(); // "CUDA:Archetype:"
    let name_pair = inner.next().unwrap();
    let name = Ident::new(name_pair.as_str());
    inner.next(); // "("

    let mut params = Vec::new();
    while let Some(pair) = inner.next() {
        if pair.as_rule() == Rule::kernel_param {
            params.push(parse_kernel_param(pair)?);
            // Next should be , or )
            let next = inner.next();
            if let Some(sep) = next {
                if sep.as_str() == "," {
                    // Skip WHITESPACE*
                    let ws = inner.next();
                    if let Some(ws_pair) = ws {
                        if ws_pair.as_rule() != Rule::WHITESPACE {
                            return Err(ParseError::ParseTree(
                                "Expected whitespace after comma".to_string(),
                            ));
                        }
                    }
                } else if sep.as_str() == ")" {
                    break;
                } else {
                    return Err(ParseError::ParseTree(format!(
                        "Expected , or ), got {}",
                        sep.as_str()
                    )));
                }
            }
        } else if pair.as_str() == ")" {
            break;
        } else {
            return Err(ParseError::ParseTree(format!(
                "Unexpected in kernel archetype: {:?}",
                pair.as_rule()
            )));
        }
    }

    Ok(KernelArchetype { name, params })
}

/// Parse kernel declaration: semantic_ident := kernel_archetype
fn parse_kernel_decl(pair: Pair<Rule>) -> Result<Stmt, ParseError> {
    let mut inner = pair.into_inner();
    let semantic_ident_pair = inner.next().unwrap();
    let semantic_ident = {
        let mut si_inner = semantic_ident_pair.into_inner();
        let prefix_pair = si_inner.next().unwrap();
        let name_pair = si_inner.next().unwrap();
        let prefix = prefix_pair.as_str().chars().next().unwrap();
        let name = Ident::new(name_pair.as_str());
        SemanticIdent::new(prefix, name)
    };

    inner.next(); // :=
    inner.next(); // WHITESPACE*
    let kernel_archetype_pair = inner.next().unwrap();
    let archetype = parse_kernel_archetype(kernel_archetype_pair)?;

    Ok(Stmt::KernelDecl {
        name: semantic_ident,
        archetype,
    })
}

/// Parse expression using grammar-driven precedence.
///
/// We rely on the Pest grammar to encode precedence via nested rules:
/// - `flow_expr` wraps `struct_expr` (lower precedence)
/// - `struct_expr` wraps `access` (higher precedence)
/// - `access` wraps `term`
///
/// Each non-terminal is parsed as:
///   sub_expr (op sub_expr)*
fn parse_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    match pair.as_rule() {
        // Expression layers for structural operators
        Rule::relation_expr | Rule::flow_expr | Rule::struct_expr | Rule::access => {
            let mut inner = pair.into_inner();

            // First element is always a sub-expression or term.
            let first = inner
                .next()
                .ok_or_else(|| ParseError::ParseTree("Empty expression".to_string()))?;

            let mut left = match first.as_rule() {
                Rule::relation_expr | Rule::flow_expr | Rule::struct_expr | Rule::access => {
                    parse_expr(first)?
                }
                Rule::term => parse_term(first)?,
                _ => parse_term(first)?,
            };

            // Then we expect zero or more (op, rhs) pairs.
            while let Some(op_pair) = inner.next() {
                // Determine what kind of pair this is
                let (op, right) = match op_pair.as_rule() {
                    // If it's one of the named operator rules, parse it
                    Rule::relation_op | Rule::flow_op | Rule::struct_op | Rule::path_op => {
                        let op = parse_operator(op_pair)?;
                        let rhs_pair = inner.next().ok_or_else(|| {
                            ParseError::ParseTree("Missing right operand".to_string())
                        })?;
                        let right = match rhs_pair.as_rule() {
                            Rule::relation_expr
                            | Rule::flow_expr
                            | Rule::struct_expr
                            | Rule::access => parse_expr(rhs_pair)?,
                            Rule::term => parse_term(rhs_pair)?,
                            _ => parse_term(rhs_pair)?,
                        };
                        (op, right)
                    }
                    // If it's another expression layer, something is wrong
                    Rule::access | Rule::struct_expr | Rule::flow_expr | Rule::relation_expr => {
                        return Err(ParseError::ParseTree(format!(
                            "Unexpected expression node where operator expected: {:?}",
                            op_pair.as_rule()
                        )));
                    }
                    _ => {
                        // Fallback: treat as operator by text
                        let op = parse_operator(op_pair)?;
                        let rhs_pair = inner.next().ok_or_else(|| {
                            ParseError::ParseTree("Missing right operand".to_string())
                        })?;
                        let right = match rhs_pair.as_rule() {
                            Rule::relation_expr
                            | Rule::flow_expr
                            | Rule::struct_expr
                            | Rule::access => parse_expr(rhs_pair)?,
                            Rule::term => parse_term(rhs_pair)?,
                            _ => parse_term(rhs_pair)?,
                        };
                        (op, right)
                    }
                };

                left = Expr::binary(left, op, right);
            }

            Ok(left)
        }
        // Direct term -> literal / ident / grouped expr
        Rule::term => parse_term(pair),
        _ => Err(ParseError::ParseTree(format!(
            "Unexpected expression rule: {:?}",
            pair.as_rule()
        ))),
    }
}

/// Parse a term: identifier, number, string, array, grouped expression, or math block.
fn parse_term(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    match pair.as_rule() {
        Rule::term => {
            // Term is a composite rule, get its inner content
            let inner = pair
                .into_inner()
                .next()
                .ok_or_else(|| ParseError::ParseTree("Empty term".to_string()))?;
            parse_term(inner) // Recursively parse the inner rule
        }
        Rule::array_literal => {
            // Parse array literal: [expr, expr, ...]
            let inner = pair.into_inner();
            let mut elements = Vec::new();

            for expr_pair in inner {
                elements.push(parse_expr(expr_pair)?);
            }

            Ok(Expr::Term(Term::Literal(Literal::Array(elements))))
        }
        Rule::semantic_ident => {
            // Parse semantic identifier: prefix:name
            let mut inner = pair.into_inner();
            let prefix_pair = inner.next().unwrap();
            let name_pair = inner.next().unwrap();

            // Extract prefix character (first char before the colon)
            let prefix_str = prefix_pair.as_str();
            let prefix = prefix_str.chars().next().unwrap();

            let name = name_pair.as_str();
            Ok(Expr::Term(Term::semantic_ident(prefix, name)))
        }
        Rule::ident => Ok(Expr::ident(pair.as_str())),
        Rule::fn_call => {
            // Parse function call: name(arg1, arg2, ...)
            let mut inner = pair.into_inner();
            let name_pair = inner
                .next()
                .ok_or_else(|| ParseError::ParseTree("Missing function name".to_string()))?;
            let name = Ident::new(name_pair.as_str());

            let mut args = Vec::new();
            for expr_pair in inner {
                args.push(parse_expr(expr_pair)?);
            }

            Ok(Expr::Term(Term::FunctionCall { name, args }))
        }
        Rule::number => {
            let num: f64 = pair
                .as_str()
                .parse()
                .map_err(|_| ParseError::ExpectedNumber(pair.as_str().to_string()))?;
            Ok(Expr::literal(num))
        }
        Rule::boolean_literal => {
            // Parse boolean literal: B:t (true) or B:f (false)
            let text = pair.as_str();
            match text {
                "B:t" => Ok(Expr::Term(Term::Literal(Literal::bool(true)))),
                "B:f" => Ok(Expr::Term(Term::Literal(Literal::bool(false)))),
                _ => Err(ParseError::ParseTree(format!(
                    "Invalid boolean literal: {}",
                    text
                ))),
            }
        }
        Rule::string => {
            // Parse string, handling escape sequences
            let raw = pair.as_str();
            // Remove surrounding quotes
            let content = &raw[1..raw.len() - 1];
            // Unescape common sequences
            let unescaped = content
                .replace("\\\"", "\"")
                .replace("\\\\", "\\")
                .replace("\\n", "\n")
                .replace("\\r", "\r")
                .replace("\\t", "\t");
            Ok(Expr::Term(Term::Literal(Literal::String(unescaped))))
        }
        Rule::relation_expr | Rule::flow_expr | Rule::struct_expr | Rule::access => {
            // These are expression nodes that can appear as terms (e.g., in parentheses)
            parse_expr(pair)
        }
        Rule::math_block => {
            // Math blocks are at the term level, parse content as math expression
            let math_expr = parse_math_expr(pair)?;
            Ok(Expr::Term(Term::Math(Box::new(math_expr))))
        }
        _ => Err(ParseError::ParseTree(format!(
            "Unexpected term rule: {:?}",
            pair.as_rule()
        ))),
    }
}

/// Parse math expression from a math block `[...]`.
/// Handles arithmetic operators with proper precedence.
fn parse_math_expr(pair: Pair<Rule>) -> Result<MathExpr, ParseError> {
    // The pair is a math_block, we need the inner math_expr
    let math_expr_pair = pair
        .into_inner()
        .next()
        .ok_or_else(|| ParseError::ParseTree("Empty math block".to_string()))?;

    parse_math_expr_inner(math_expr_pair)
}

/// Internal math expression parser.
fn parse_math_expr_inner(pair: Pair<Rule>) -> Result<MathExpr, ParseError> {
    match pair.as_rule() {
        Rule::math_expr | Rule::math_add | Rule::math_mul | Rule::math_exp => {
            let mut inner = pair.into_inner();

            let first = inner
                .next()
                .ok_or_else(|| ParseError::ParseTree("Empty math expression".to_string()))?;

            let mut left = match first.as_rule() {
                Rule::math_expr | Rule::math_add | Rule::math_mul | Rule::math_exp => {
                    parse_math_expr_inner(first)?
                }
                Rule::math_unary => parse_math_unary(first)?,
                Rule::math_atom => parse_math_atom(first)?,
                _ => parse_math_expr_inner(first)?,
            };

            while let Some(op_pair) = inner.next() {
                let op = parse_math_operator(op_pair)?;

                let rhs_pair = inner.next().ok_or_else(|| {
                    ParseError::ParseTree("Missing right operand in math".to_string())
                })?;

                let right = match rhs_pair.as_rule() {
                    Rule::math_expr | Rule::math_add | Rule::math_mul | Rule::math_exp => {
                        parse_math_expr_inner(rhs_pair)?
                    }
                    Rule::math_unary => parse_math_unary(rhs_pair)?,
                    Rule::math_atom => parse_math_atom(rhs_pair)?,
                    _ => parse_math_atom(rhs_pair)?,
                };

                left = MathExpr::binary(left, op, right);
            }

            Ok(left)
        }
        Rule::math_unary => parse_math_unary(pair),
        Rule::math_atom => parse_math_atom(pair),
        _ => Err(ParseError::ParseTree(format!(
            "Unexpected math expression rule: {:?}",
            pair.as_rule()
        ))),
    }
}

/// Parse a math atom: number, identifier, or grouped expression.
fn parse_math_atom(pair: Pair<Rule>) -> Result<MathExpr, ParseError> {
    let inner = pair
        .into_inner()
        .next()
        .ok_or_else(|| ParseError::ParseTree("Empty math atom".to_string()))?;

    match inner.as_rule() {
        Rule::number => {
            let num: f64 = inner
                .as_str()
                .parse()
                .map_err(|_| ParseError::ExpectedNumber(inner.as_str().to_string()))?;
            Ok(MathExpr::atom(MathAtom::Number(num)))
        }
        Rule::ident => Ok(MathExpr::atom(MathAtom::Ident(Ident::new(inner.as_str())))),
        Rule::semantic_ident => {
            // Parse semantic identifier inside math blocks - treat as regular identifier for now
            Ok(MathExpr::atom(MathAtom::Ident(Ident::new(inner.as_str()))))
        }
        Rule::math_array_literal => {
            // Parse array literal inside math blocks
            let elements: Result<Vec<MathExpr>, ParseError> =
                inner.into_inner().map(parse_math_expr_inner).collect();
            Ok(MathExpr::atom(MathAtom::Array(elements?)))
        }
        Rule::math_expr => Ok(MathExpr::atom(MathAtom::Group(Box::new(
            parse_math_expr_inner(inner)?,
        )))),
        _ => Err(ParseError::ParseTree(format!(
            "Unexpected math atom rule: {:?}",
            inner.as_rule()
        ))),
    }
}

/// Parse unary expression: optional prefix operator followed by atom.
fn parse_math_unary(pair: Pair<Rule>) -> Result<MathExpr, ParseError> {
    let mut inner = pair.into_inner();

    let first = inner
        .next()
        .ok_or_else(|| ParseError::ParseTree("Empty unary expression".to_string()))?;

    // Check if first is a unary operator
    match first.as_rule() {
        Rule::math_unary_op => {
            let op = parse_math_unary_operator(first)?;
            let operand_pair = inner.next().ok_or_else(|| {
                ParseError::ParseTree("Missing operand after unary operator".to_string())
            })?;

            let operand = match operand_pair.as_rule() {
                Rule::math_atom => parse_math_atom(operand_pair)?,
                Rule::math_unary => parse_math_unary(operand_pair)?,
                _ => {
                    return Err(ParseError::ParseTree(format!(
                        "Unexpected unary operand rule: {:?}",
                        operand_pair.as_rule()
                    )));
                }
            };

            Ok(MathExpr::unary(op, operand))
        }
        Rule::math_atom => parse_math_atom(first),
        _ => Err(ParseError::ParseTree(format!(
            "Unexpected unary rule: {:?}",
            first.as_rule()
        ))),
    }
}

/// Parse math operator into MathOp.
fn parse_math_operator(pair: Pair<Rule>) -> Result<MathOp, ParseError> {
    match pair.as_str().trim() {
        "+" => Ok(MathOp::Add),
        "-" => Ok(MathOp::Subtract),
        "*" => Ok(MathOp::Multiply),
        "/" => Ok(MathOp::Divide),
        "%" => Ok(MathOp::Modulo),
        "^" => Ok(MathOp::Power),
        "R" => Ok(MathOp::Root),
        op => Err(ParseError::InvalidOperator(format!(
            "Unknown math operator: {}",
            op
        ))),
    }
}

/// Parse unary operator into MathUnaryOp.
fn parse_math_unary_operator(pair: Pair<Rule>) -> Result<MathUnaryOp, ParseError> {
    match pair.as_str().trim() {
        "-" => Ok(MathUnaryOp::Negate),
        "+" => Ok(MathUnaryOp::Plus),
        op => Err(ParseError::InvalidOperator(format!(
            "Unknown unary operator: {}",
            op
        ))),
    }
}

/// Parse operator token into RuneOp.
///
/// We defensively trim whitespace so that rules which
/// include incidental spaces around operators do not
/// accidentally produce `"+"`, `"1 "` or `"b * c"` as a
/// single operator token.
fn parse_operator(pair: Pair<Rule>) -> Result<RuneOp, ParseError> {
    let text = pair.as_str().trim();
    RuneOp::from_str(text).map_err(|_| ParseError::InvalidOperator(text.to_string()))
}

File: ops.rs
============
//! Core Operator Registry and Definitions for RUNE.
//!
//! # e8 Notation – RUNE Operators
//!▫~•◦----------------------------‣
//!
//! This module defines the strict, closed registry of valid RUNE operators.
//! It maps the text representations (from the grammar) to strongly-typed
//! Rust enums, ensuring that no "illegal" or "fused" operators can represent
//! a valid state in the AST.
//!
//! ### Key Capabilities
//! - **Closed Registry:** `RuneOp` enum exhaustively lists every allowed operator.
//! - **Category Safety:** Distinguishes between `Glyph` (Topological), `Relation` (Directed), and `Math` (Value).
//! - **Precedence Logic:** Defines binding power for Pratt parsing (e.g., `*` binds tighter than `+`, which binds tighter than `->`).
//!
//! ### Example
//! ```rust
//! use rune_format::rune::RuneOp;
//! use std::str::FromStr;
//!
//! let op = RuneOp::from_str("->").unwrap();
//! assert_eq!(op, RuneOp::FlowRight);
//! assert_eq!(op.category(), rune_format::rune::OpCategory::Relation);
//! ```
//!
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

#[cfg(feature = "fory")]
use fory::ForyObject;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::str::FromStr;

/// Categories of operators in RUNE.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[cfg_attr(feature = "fory", derive(ForyObject))]
pub enum OpCategory {
    /// Topological shapes (e.g., `/\`, `\|/`).
    Glyph,
    /// Structural relations (e.g., `->`, `:`, `:=`).
    Relation,
    /// Value comparisons (e.g., `<`, `>`).
    Compare,
    /// Arithmetic operations (e.g., `+`, `*`).
    Math,
}

/// The Closed Registry of all valid RUNE operators.
///
/// Any sequence of characters not matching one of these variants
/// is syntactically invalid in RUNE.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[cfg_attr(feature = "fory", derive(ForyObject))]
pub enum RuneOp {
    // --- 1. Glyph Operators (Topology/Shape) ---
    /// `/\` : Branch then converge (Split -> Join).
    SplitJoin,
    /// `\/` : Converge then branch (Join -> Split).
    JoinSplit,
    /// `|/` : Stable lineage then branch away (Descend from Anchor).
    AnchorDescend,
    /// `/|` : Branch away then stabilize (Branch -> Stabilize).
    BranchStabilize,
    /// `\|` : Converge to root then stabilize.
    RootStabilize,
    /// `|\` : Stabilize then converge to root.
    StabilizeRoot,
    /// `\|/` : Symmetric split from a stable center.
    SymmetricSplit,
    /// `/|\` : Branch, Anchor, Branch (Composite).
    BranchAnchorBranch,

    // --- 2. Token Operators (Relations) ---
    /// `:` : Bind / Key-Value / Annotation.
    Bind,
    /// `=:` : Specializes / Instance of / Emergent from.
    Specializes,
    /// `::` : Namespace / Type Tag.
    Namespace,
    /// `:=` : Definition / Assignment.
    Define,
    /// `:=:` : Match / Pattern recognition.
    Match,
    /// `=:=` : Unify / Structural isomorphism.
    Unify,
    /// `=` : Equality / Constraint (Invariant).
    Equal,
    /// `->` : Directed Edge (Flow Right / Rootwards).
    /// Creates a forward directional flow between entities,
    /// typically representing data movement, inheritance, or sequential processing.
    FlowRight,
    /// `<-` : Reverse Edge (Flow Left).
    /// Creates a reverse directional flow, often representing
    /// backpropagation, parent flows, or inverse transformations.
    FlowLeft,
    /// `<->` : Bidirectional flow / Oscillation / Exchange.
    /// Represents oscillating or bidirectional exchange patterns,
    /// such as duality relationships, resonant couplings, or
    /// feedback loops between entities.
    FlowBidirectional,
    /// `>-<` : Convergent flow / Transformation focus.
    /// Denotes transformative convergence, such as energy compression,
    /// gradient descent, or focused transformation pathways.
    FlowConvergent,
    /// `/` : Descendant / Under (Structural Context).
    Descendant,
    /// `\` : Ancestor / Parent (Sugar for `->` in some contexts).
    Ancestor,
    /// `|` : Alias / Equivalence.
    Alias,
    /// `||` : Parallel / Siblings.
    Parallel,
    /// `~` : Transform / View.
    Transform,
    /// `|>` : Pipeline Right / Function composition (left-to-right).
    PipelineRight,
    /// `<|` : Pipeline Left / Reverse function composition (right-to-left).
    PipelineLeft,
    /// `:>` : Output / Produces / Generates (context yields output).
    Output,
    /// `<:` : Input / Requires / Accepts (context needs input).
    Input,

    // --- 4. Comparison ---
    /// `<` : Less / Precedes / Deeper.
    Less,
    /// `<=` : Less than or equal.
    LessEqual,
    /// `>` : Greater / Succeeds / Higher.
    Greater,
    /// `>=` : Greater than or equal.
    GreaterEqual,
}

impl RuneOp {
    /// Returns the semantic category of the operator.
    pub fn category(&self) -> OpCategory {
        match self {
            Self::SplitJoin
            | Self::JoinSplit
            | Self::AnchorDescend
            | Self::BranchStabilize
            | Self::RootStabilize
            | Self::StabilizeRoot
            | Self::SymmetricSplit
            | Self::BranchAnchorBranch => OpCategory::Glyph,

            Self::Bind
            | Self::Specializes
            | Self::Namespace
            | Self::Define
            | Self::Match
            | Self::Unify
            | Self::Equal
            | Self::FlowRight
            | Self::FlowLeft
            | Self::FlowBidirectional
            | Self::FlowConvergent
            | Self::Descendant
            | Self::Ancestor
            | Self::Alias
            | Self::Parallel
            | Self::Transform
            | Self::PipelineRight
            | Self::PipelineLeft
            | Self::Output
            | Self::Input => OpCategory::Relation,

            Self::Less | Self::LessEqual | Self::Greater | Self::GreaterEqual => {
                OpCategory::Compare
            }
        }
    }

    /// Returns the textual representation of the operator.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::SplitJoin => "/\\",
            Self::JoinSplit => "\\/",
            Self::AnchorDescend => "|/",
            Self::BranchStabilize => "/|",
            Self::RootStabilize => "\\|",
            Self::StabilizeRoot => "|\\",
            Self::SymmetricSplit => "\\|/",
            Self::BranchAnchorBranch => "/|\\",

            Self::Bind => ":",
            Self::Specializes => "=:",
            Self::Namespace => "::",
            Self::Define => ":=",
            Self::Match => ":=:",
            Self::Unify => "=:=",
            Self::Equal => "=",
            Self::FlowRight => "->",
            Self::FlowLeft => "<-",
            Self::FlowBidirectional => "<->",
            Self::FlowConvergent => ">-<",
            Self::Descendant => "/",
            Self::Ancestor => "\\",
            Self::Alias => "|",
            Self::Parallel => "||",
            Self::Transform => "~",
            Self::PipelineRight => "|>",
            Self::PipelineLeft => "<|",
            Self::Output => ":>",
            Self::Input => "<:",

            Self::Less => "<",
            Self::LessEqual => "<=",
            Self::Greater => ">",
            Self::GreaterEqual => ">=",
        }
    }

    /// Binding Power for Pratt Parsing (Precedence).
    ///
    /// Higher numbers bind tighter.
    /// - Namespace/Path: Structural binding
    /// - Flow / Glyphs / Transform: mid-tier
    /// - Comparison: lower
    /// - Bind / Define: lowest (top-level)
    pub fn binding_power(&self) -> (u8, u8) {
        match self {
            // Namespace / Path / Hierarchy
            Self::Namespace => (70, 71),
            Self::Descendant | Self::Ancestor => (60, 61),

            // Flow / Graph Edges / Glyphs / Transform
            Self::FlowRight
            | Self::FlowLeft
            | Self::FlowBidirectional
            | Self::FlowConvergent
            | Self::SplitJoin
            | Self::JoinSplit
            | Self::SymmetricSplit
            | Self::BranchAnchorBranch
            | Self::Transform
            | Self::AnchorDescend
            | Self::BranchStabilize
            | Self::RootStabilize
            | Self::StabilizeRoot => (50, 51),

            // Comparison
            Self::Less | Self::LessEqual | Self::Greater | Self::GreaterEqual | Self::Equal => {
                (40, 41)
            }

            // Loose Structure
            Self::Parallel | Self::Alias => (30, 31),

            // Additional relation operators
            Self::Specializes
            | Self::Match
            | Self::Unify
            | Self::PipelineRight
            | Self::PipelineLeft
            | Self::Output
            | Self::Input => (35, 36),

            // Definition / Assignment / Bind: Lowest
            Self::Bind | Self::Define => (10, 11),
        }
    }
}

/// Parsing error for invalid operator strings.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct InvalidOpError(pub String);

impl fmt::Display for InvalidOpError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Invalid RUNE operator literal: '{}'", self.0)
    }
}

impl std::error::Error for InvalidOpError {}

impl FromStr for RuneOp {
    type Err = InvalidOpError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            // Glyphs (3-char)
            "\\|/" => Ok(Self::SymmetricSplit),
            "/|\\" => Ok(Self::BranchAnchorBranch),

            // Glyphs (2-char)
            "/\\" => Ok(Self::SplitJoin),
            "\\/" => Ok(Self::JoinSplit),
            "|/" => Ok(Self::AnchorDescend),
            "/|" => Ok(Self::BranchStabilize),
            "\\|" => Ok(Self::RootStabilize),
            "|\\" => Ok(Self::StabilizeRoot),

            // Tokens (3-char)
            "=:=" => Ok(Self::Unify),
            ":=:" => Ok(Self::Match),

            // Tokens (3-char)
            "|>" => Ok(Self::PipelineRight),
            "<|" => Ok(Self::PipelineLeft),
            ":>" => Ok(Self::Output),
            "<:" => Ok(Self::Input),

            // Tokens (3-char) - Flow
            "<->" => Ok(Self::FlowBidirectional),
            ">-<" => Ok(Self::FlowConvergent),

            // Tokens (2-char)
            "=:" => Ok(Self::Specializes),
            "::" => Ok(Self::Namespace),
            ":=" => Ok(Self::Define),
            "->" => Ok(Self::FlowRight),
            "<-" => Ok(Self::FlowLeft),
            "<=" => Ok(Self::LessEqual),
            ">=" => Ok(Self::GreaterEqual),
            "||" => Ok(Self::Parallel),

            // Tokens (1-char)
            ":" => Ok(Self::Bind),
            "=" => Ok(Self::Equal),
            "<" => Ok(Self::Less),
            ">" => Ok(Self::Greater),
            "/" => Ok(Self::Descendant),
            "\\" => Ok(Self::Ancestor),
            "|" => Ok(Self::Alias),
            "~" => Ok(Self::Transform),

            _ => Err(InvalidOpError(s.to_string())),
        }
    }
}

/// Arithmetic operators within math blocks.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[cfg_attr(feature = "fory", derive(ForyObject))]
pub enum MathOp {
    Add,
    Subtract,
    Multiply,
    Divide,
    Power, // ^ operator
    Modulo,
    Root, // R operator: n-th root
}

impl MathOp {
    pub fn precedence(self) -> u8 {
        match self {
            MathOp::Add | MathOp::Subtract => 1,                     // + -
            MathOp::Multiply | MathOp::Divide | MathOp::Modulo => 2, // * / %
            MathOp::Power | MathOp::Root => 3,                       // ^ R
        }
    }

    pub fn as_str(self) -> &'static str {
        match self {
            MathOp::Add => "+",
            MathOp::Subtract => "-",
            MathOp::Multiply => "*",
            MathOp::Divide => "/",
            MathOp::Power => "^",
            MathOp::Modulo => "%",
            MathOp::Root => "R",
        }
    }
}

impl fmt::Display for MathOp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

impl fmt::Display for RuneOp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_operator_from_str() {
        assert_eq!(RuneOp::from_str("->").unwrap(), RuneOp::FlowRight);
        assert_eq!(RuneOp::from_str("<-").unwrap(), RuneOp::FlowLeft);
        assert_eq!(RuneOp::from_str("<->").unwrap(), RuneOp::FlowBidirectional);
        assert_eq!(RuneOp::from_str(">-<").unwrap(), RuneOp::FlowConvergent);
        assert_eq!(RuneOp::from_str("/\\").unwrap(), RuneOp::SplitJoin);
        assert_eq!(RuneOp::from_str(":=").unwrap(), RuneOp::Define);
        assert_eq!(RuneOp::from_str("=:=").unwrap(), RuneOp::Unify);
        assert_eq!(RuneOp::from_str(":=:").unwrap(), RuneOp::Match);
        assert_eq!(RuneOp::from_str("=:").unwrap(), RuneOp::Specializes);
        assert_eq!(RuneOp::from_str("|>").unwrap(), RuneOp::PipelineRight);
        assert_eq!(RuneOp::from_str("<|").unwrap(), RuneOp::PipelineLeft);
        assert_eq!(RuneOp::from_str(":>").unwrap(), RuneOp::Output);
        assert_eq!(RuneOp::from_str("<:").unwrap(), RuneOp::Input);
    }

    #[test]
    fn test_invalid_operator() {
        assert!(RuneOp::from_str("=>").is_err());
        assert!(RuneOp::from_str("/->").is_err());
        assert!(RuneOp::from_str(":|").is_err());
    }

    #[test]
    fn test_binding_power() {
        assert!(RuneOp::FlowRight.binding_power() > RuneOp::Define.binding_power());
    }
}

File: ast.rs
============
/* src/rune/ast.rs */
//! RUNE Abstract Syntax Tree (AST) definitions.
//!
//! # TOON-RUNE – RUNE AST Module
//!▫~•◦---------------------------‣
//!
//! This module defines the core expression tree structures for RUNE:
//! identifiers, literals, terms, and expressions built on `RuneOp`.
//! It also includes statement-level constructs for TOON blocks and root declarations.
//!
//! The AST is intentionally minimal and expression-centric. Higher-level
//! constructs (definitions, constraints, blocks) can be layered on top
//! without changing the fundamental expression nodes.
//!
//! ### Key Types
//! - [`Literal`] – Numeric values.
//! - [`Ident`]   – Symbolic names (types, tensors, nodes, roots).
//! - [`Term`]    – Basic units: identifiers, literals, grouped expressions.
//! - [`Expr`]    – Recursive expression tree parameterized by [`RuneOp`].
//! - [`Stmt`]    – Top-level statements: root declarations, TOON blocks, expressions.
//!
//! ### Example
//! ```rust
//! use rune_format::rune::{Stmt, Expr};
//! use rune_format::rune::RuneOp;
//!
//! let root_stmt = Stmt::root("continuum");
//! let expr_stmt = Stmt::expr(
//!     Expr::binary(
//!         Expr::ident("users"),
//!         RuneOp::Descendant,
//!         Expr::ident("0"),
//!     )
//! );
//! ```
//!
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use crate::rune::ops::{MathOp, RuneOp};
use serde::{Deserialize, Serialize};
use std::fmt;

/// Basic type system for RUNE expressions.
/// This is intentionally small to bootstrap typed AST and inference.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RuneType {
    Scalar,
    String,
    Gf8,
    PointCloud,
    Array,
    Bool,
    Unknown,
}

impl fmt::Display for RuneType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RuneType::Scalar => write!(f, "Scalar"),
            RuneType::String => write!(f, "String"),
            RuneType::Gf8 => write!(f, "Gf8"),
            RuneType::PointCloud => write!(f, "PointCloud"),
            RuneType::Array => write!(f, "Array"),
            RuneType::Bool => write!(f, "Bool"),
            RuneType::Unknown => write!(f, "Unknown"),
        }
    }
}

/// A parameter in a kernel archetype declaration.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct KernelParam {
    pub name: Ident,
    pub typ: Ident,
}

/// Information about a single archetype in a kernel declaration.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ArchetypeInfo {
    pub name: Ident,
    pub params: Vec<KernelParam>,
}

/// A kernel archetype definition with parameters.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KernelArchetype {
    pub name: Ident,
    pub params: Vec<(Ident, Literal)>,
}

/// A symbolic identifier in RUNE.
///
/// This covers type symbols (`T`, `Gf8`, `XUID`), nodes, roots,
/// fields, and any named entities.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Ident(pub String);

impl Ident {
    pub fn new<S: Into<String>>(s: S) -> Self {
        Ident(s.into())
    }
}

impl fmt::Display for Ident {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl From<String> for Ident {
    fn from(s: String) -> Self {
        Ident::new(s)
    }
}

impl From<&str> for Ident {
    fn from(s: &str) -> Self {
        Ident::new(s)
    }
}

impl Into<String> for Ident {
    fn into(self) -> String {
        self.0
    }
}

/// A semantic identifier with a single-letter namespace prefix.
///
/// Examples: T:Gf8, V:vector, R:continuum, Q:e32l
/// The prefix is always a single uppercase letter (A-Z).
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SemanticIdent {
    /// The semantic prefix (A-Z)
    pub prefix: char,
    /// The identifier name
    pub name: Ident,
}

impl SemanticIdent {
    pub fn new(prefix: char, name: impl Into<String>) -> Self {
        SemanticIdent {
            prefix,
            name: Ident::new(name),
        }
    }
}

impl fmt::Display for SemanticIdent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.prefix, self.name)
    }
}

/// Literal values in RUNE expressions.
///
/// Supports numeric literals, strings, arrays, and booleans.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Literal {
    /// Numeric literal (parsed as f64).
    Number(f64),
    /// String literal.
    String(String),
    /// Boolean literal: B:t (true) or B:f (false)
    Bool(bool),
    /// Array literal: [1,2,3] or [a,b,c]
    Array(Vec<Expr>),
}

impl Literal {
    pub fn number<N: Into<f64>>(n: N) -> Self {
        Literal::Number(n.into())
    }

    pub fn string<S: Into<String>>(s: S) -> Self {
        Literal::String(s.into())
    }

    pub fn bool<B: Into<bool>>(b: B) -> Self {
        Literal::Bool(b.into())
    }

    pub fn array(elements: Vec<Expr>) -> Self {
        Literal::Array(elements)
    }
}

impl fmt::Display for Literal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Literal::Number(n) => write!(f, "{}", n),
            Literal::String(s) => write!(f, "\"{}\"", s),
            Literal::Bool(b) => write!(f, "B:{}", if *b { "t" } else { "f" }),
            Literal::Array(elements) => {
                write!(f, "[")?;
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        write!(f, ",")?;
                    }
                    write!(f, "{}", elem)?;
                }
                write!(f, "]")
            }
        }
    }
}

/// Arithmetic expressions within `[...]` value blocks.
///
/// These support traditional math with operators: `+ - * /`.
/// Isolated from glyph operators for clean separation.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum MathExpr {
    /// A single math atom (identifier, number, or grouped math).
    Atom(MathAtom),

    /// A binary math operation `lhs op rhs`.
    Binary {
        left: Box<MathExpr>,
        op: MathOp,
        right: Box<MathExpr>,
    },

    /// A unary math operation `op expr` (e.g., `-x`, `+5`).
    Unary {
        op: MathUnaryOp,
        operand: Box<MathExpr>,
    },
}

/// Unary operators in arithmetic expressions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum MathUnaryOp {
    /// Negation `-x`.
    Negate,
    /// Positive `+x` (typically a no-op).
    Plus,
}

impl MathUnaryOp {
    pub fn as_str(self) -> &'static str {
        match self {
            MathUnaryOp::Negate => "-",
            MathUnaryOp::Plus => "+",
        }
    }
}

/// Atoms in arithmetic expressions.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum MathAtom {
    /// Numeric literal.
    Number(f64),
    /// Variable identifier.
    Ident(Ident),
    /// Grouped sub-expression `(math)` (for precedence).
    Group(Box<MathExpr>),
    /// Array literal inside math block `[expr, expr, ...]`.
    Array(Vec<MathExpr>),
}

impl MathExpr {
    /// Create a math atom expression.
    pub fn atom(atom: MathAtom) -> Self {
        MathExpr::Atom(atom)
    }

    /// Create a binary math expression.
    pub fn binary(left: MathExpr, op: MathOp, right: MathExpr) -> Self {
        MathExpr::Binary {
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    }

    /// Create a unary math expression.
    pub fn unary(op: MathUnaryOp, operand: MathExpr) -> Self {
        MathExpr::Unary {
            op,
            operand: Box::new(operand),
        }
    }
}

impl fmt::Display for MathExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MathExpr::Atom(atom) => match atom {
                MathAtom::Number(n) => write!(f, "{}", n),
                MathAtom::Ident(id) => write!(f, "{}", id),
                MathAtom::Group(inner) => write!(f, "({})", inner),
                MathAtom::Array(elements) => {
                    write!(f, "[")?;
                    for (i, elem) in elements.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        write!(f, "{}", elem)?;
                    }
                    write!(f, "]")
                }
            },
            MathExpr::Binary { left, op, right } => {
                // Add parens for clarity in nested operations
                write!(f, "{} {} {}", left, op, right)
            }
            MathExpr::Unary { op, operand } => {
                write!(f, "{}{}", op.as_str(), operand)
            }
        }
    }
}

/// Atomic terms in a RUNE expression.
///
/// These are the building blocks that operators connect.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Term {
    /// A named symbol (identifier).
    Ident(Ident),
    /// A semantic identifier with namespace prefix (e.g., T:Gf8, V:vector).
    SemanticIdent(SemanticIdent),
    /// A literal value.
    Literal(Literal),
    /// A grouped sub-expression `(expr)`.
    Group(Box<Expr>),
    /// Arithmetic within `[...]` value blocks.
    Math(Box<MathExpr>),
    /// A function call: name(arg1, arg2, ...)
    FunctionCall { name: Ident, args: Vec<Expr> },
}

impl Term {
    pub fn ident<S: Into<String>>(s: S) -> Self {
        Term::Ident(Ident::new(s))
    }

    pub fn semantic_ident(prefix: char, name: impl Into<String>) -> Self {
        Term::SemanticIdent(SemanticIdent::new(prefix, name))
    }

    pub fn literal<N: Into<f64>>(n: N) -> Self {
        Term::Literal(Literal::number(n))
    }

    pub fn group(expr: Expr) -> Self {
        Term::Group(Box::new(expr))
    }

    pub fn math(math: MathExpr) -> Self {
        Term::Math(Box::new(math))
    }
}

/// A full RUNE expression.
///
/// This is the node-level representation that a Pratt parser will
/// construct from a token stream (`Term`s and `RuneOp`s).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Expr {
    /// A single term (identifier, literal, or grouped expression).
    Term(Term),

    /// A binary expression `lhs op rhs`.
    Binary {
        left: Box<Expr>,
        op: RuneOp,
        right: Box<Expr>,
    },
}

impl Expr {
    /// Construct a term expression from an identifier.
    pub fn ident<S: Into<String>>(s: S) -> Self {
        Expr::Term(Term::ident(s))
    }

    /// Construct a term expression from a numeric literal.
    pub fn literal<N: Into<f64>>(n: N) -> Self {
        Expr::Term(Term::literal(n))
    }

    /// Construct a grouped expression `(expr)`.
    pub fn group(expr: Expr) -> Self {
        Expr::Term(Term::group(expr))
    }

    /// Construct a binary expression `left op right`.
    pub fn binary(left: Expr, op: RuneOp, right: Expr) -> Self {
        Expr::Binary {
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    }
}

/// A typed expression wrapper used for annotating an `Expr` node
/// with a best-effort type computed during parsing/type inference.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TypedExpr {
    pub expr: Expr,
    pub r#type: RuneType,
}

impl TypedExpr {
    pub fn new(expr: Expr, r#type: RuneType) -> Self {
        Self { expr, r#type }
    }

    /// Infer a type for a given expression node using shallow heuristics.
    /// This is intentionally conservative: only literal math/strings/arrays
    /// and some semantic hints are recognized. More advanced inference is
    /// left for a future pass.
    pub fn infer(expr: &Expr) -> Self {
        // NOTE: we avoid glob-importing Expr::* to reduce ambiguity with the Term enum
        let r#type = match expr {
            Expr::Term(term) => match term {
                crate::rune::ast::Term::Literal(crate::rune::ast::Literal::Number(_)) => {
                    RuneType::Scalar
                }
                crate::rune::ast::Term::Literal(crate::rune::ast::Literal::String(_)) => {
                    RuneType::String
                }
                crate::rune::ast::Term::Literal(crate::rune::ast::Literal::Bool(_)) => {
                    RuneType::Bool
                }
                crate::rune::ast::Term::Literal(crate::rune::ast::Literal::Array(_)) => {
                    RuneType::Array
                }
                crate::rune::ast::Term::Math(_) => RuneType::Scalar,
                crate::rune::ast::Term::Ident(_) => RuneType::Unknown,
                crate::rune::ast::Term::SemanticIdent(s) => {
                    // Heuristic: common semantic prefix T:Gf8 -> Gf8 type
                    match s.prefix {
                        'T' => {
                            if s.name.0.to_lowercase().contains("gf8") {
                                RuneType::Gf8
                            } else {
                                RuneType::Unknown
                            }
                        }
                        _ => RuneType::Unknown,
                    }
                }
                crate::rune::ast::Term::Group(inner) => TypedExpr::infer(inner).r#type.clone(),
                crate::rune::ast::Term::FunctionCall { name, args: _ } => {
                    // Heuristic: function name suggests type
                    if name.0.contains("Quat")
                        || name.0.contains("quaternion")
                        || name.0.contains("Gf8")
                    {
                        RuneType::Gf8 // quaternions are 4D, represented as scalars for now
                    } else {
                        RuneType::Unknown
                    }
                }
            },
            Expr::Binary {
                left,
                op: _,
                right: _,
            } => {
                // Binary expression type inference: prefer left-side for now
                TypedExpr::infer(left).r#type.clone()
            }
        };

        TypedExpr::new(expr.clone(), r#type)
    }
}

impl fmt::Display for Expr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Expr::Term(t) => match t {
                Term::Ident(id) => write!(f, "{}", id),
                Term::SemanticIdent(sid) => write!(f, "{}", sid),
                Term::Literal(Literal::Number(n)) => write!(f, "{}", n),
                Term::Literal(Literal::String(s)) => write!(f, "\"{}\"", s),
                Term::Literal(Literal::Bool(b)) => write!(f, "B:{}", if *b { "t" } else { "f" }),
                Term::Literal(Literal::Array(elements)) => {
                    write!(f, "[")?;
                    for (i, elem) in elements.iter().enumerate() {
                        if i > 0 {
                            write!(f, ",")?;
                        }
                        write!(f, "{}", elem)?;
                    }
                    write!(f, "]")
                }
                Term::Group(inner) => write!(f, "({})", inner),
                Term::Math(math) => write!(f, "[{}]", math),
                Term::FunctionCall { name, args } => {
                    write!(f, "{}(", name)?;
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        write!(f, "{}", arg)?;
                    }
                    write!(f, ")")
                }
            },
            Expr::Binary { left, op, right } => {
                // Don't add spaces around :: (namespace operator)
                if *op == RuneOp::Namespace {
                    write!(f, "{}::{}", left, right)
                } else {
                    write!(f, "{} {} {}", left, op, right)
                }
            }
        }
    }
}

/// Top-level RUNE statements.
///
/// These are the syntactic units parsed from RUNE files:
/// root declarations anchor contexts, TOON blocks provide raw data,
/// kernel declarations define computational archetypes,
/// and expressions allow symbolic computations over that data.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Stmt {
    /// A root declaration: `root: name`
    /// Anchors the semantic context of the document.
    RootDecl(Ident),

    /// A TOON block: `name ~TOON:\n  content`
    /// Raw TOON data preserved verbatim for later parsing by the TOON library.
    ToonBlock { name: Ident, content: String },

    /// A kernel declaration: `Kernel:QDot := CUDA:Archetype:RowDot(D: 8)`
    /// Defines a kernel from a CUDA archetype template.
    KernelDecl {
        name: SemanticIdent,
        archetype: KernelArchetype,
    },

    /// A RUNE expression statement.
    /// Typically constraints, definitions, or relations over TOON data.
    Expr(Expr),
}

impl Stmt {
    /// Create a root declaration statement.
    pub fn root<S: Into<String>>(name: S) -> Self {
        Stmt::RootDecl(Ident::new(name))
    }

    /// Create a TOON block statement.
    pub fn toon_block<S: Into<String>>(name: S, content: String) -> Self {
        Stmt::ToonBlock {
            name: Ident::new(name),
            content,
        }
    }

    /// Create an expression statement.
    pub fn expr(expr: Expr) -> Self {
        Stmt::Expr(expr)
    }
}

impl fmt::Display for Stmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Stmt::RootDecl(name) => write!(f, "root: {}", name),
            Stmt::ToonBlock { name, content } => {
                writeln!(f, "{} ~TOON:", name)?;
                for line in content.lines() {
                    writeln!(f, "  {}", line)?;
                }
                Ok(())
            }
            Stmt::KernelDecl { name, archetype } => {
                write!(f, "{} := {}", name, archetype.name)?;
                if !archetype.params.is_empty() {
                    write!(f, "(")?;
                    for (i, (param_name, param_value)) in archetype.params.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        write!(f, "{}: {}", param_name, param_value)?;
                    }
                    write!(f, ")")?;
                }
                Ok(())
            }
            Stmt::Expr(expr) => write!(f, "{}", expr),
        }
    }
}

/// Typed form of top-level statements.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum StmtTyped {
    RootDecl(Ident),
    ToonBlock {
        name: Ident,
        content: String,
    },
    KernelDecl {
        name: SemanticIdent,
        archetype: KernelArchetype,
    },
    Expr(TypedExpr),
}

impl StmtTyped {
    pub fn root<S: Into<String>>(name: S) -> Self {
        StmtTyped::RootDecl(Ident::new(name))
    }

    pub fn toon_block<S: Into<String>>(name: S, content: String) -> Self {
        StmtTyped::ToonBlock {
            name: Ident::new(name),
            content,
        }
    }

    pub fn expr(expr: TypedExpr) -> Self {
        StmtTyped::Expr(expr)
    }
}

impl fmt::Display for StmtTyped {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            StmtTyped::RootDecl(name) => write!(f, "root: {}", name),
            StmtTyped::ToonBlock { name, content } => {
                writeln!(f, "{} ~TOON:", name)?;
                for line in content.lines() {
                    writeln!(f, "  {}", line)?;
                }
                Ok(())
            }
            StmtTyped::KernelDecl { name, archetype } => {
                write!(f, "{} := {}", name, archetype.name)?;
                if !archetype.params.is_empty() {
                    write!(f, "(")?;
                    for (i, (param_name, param_value)) in archetype.params.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        write!(f, "{}: {}", param_name, param_value)?;
                    }
                    write!(f, ")")?;
                }
                Ok(())
            }
            StmtTyped::Expr(te) => write!(f, "{} :: {:?}", te.expr, te.r#type),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::rune::ops::RuneOp;

    #[test]
    fn test_expr_binary() {
        let left = Expr::ident("users");
        let right = Expr::literal(0.0);
        let expr = Expr::binary(left, RuneOp::Descendant, right);
        assert_eq!(format!("{}", expr), "users / 0");
    }

    #[test]
    fn test_stmt_root() {
        let stmt = Stmt::root("continuum");
        assert_eq!(format!("{}", stmt), "root: continuum");
    }

    #[test]
    fn test_stmt_toon_block() {
        let content = "items[2]{id,name}:\n  1,hello\n  2,world".to_string();
        let stmt = Stmt::toon_block("data", content);
        let output = format!("{}", stmt);
        assert!(output.contains("data ~TOON:"));
        assert!(output.contains("  items[2]"));
    }
}

File: hydron\cuda.rs
====================
//! CUDA-specific evaluation bridge for Hydron operations.
//!
//! Provides GPU-accelerated implementations for DomR computations using the rune-curs
//! CUDA acceleration layer.

#[cfg(feature = "cuda")]
use rune_curs as curs;
use rune_hex::hex;

/// CUDA accelerator for Hydron operations
#[derive(Debug, Clone)]
pub struct CudaAccelerator {
    /// Whether CUDA is available on this system
    cuda_available: bool,
}

impl CudaAccelerator {
    /// Create a new CUDA accelerator and check availability
    pub fn new() -> Self {
        #[cfg(feature = "cuda")]
        let cuda_available = true; // Assume available if compiled with feature

        #[cfg(not(feature = "cuda"))]
        let cuda_available = false;

        Self { cuda_available }
    }

    /// Check if CUDA acceleration is available
    pub fn is_available(&self) -> bool {
        self.cuda_available
    }

    /// Execute CUDA-accelerated DomR computation if available
    pub fn execute_domr(
        &self,
        operation: &str,
        energy_args: &[crate::rune::hydron::values::Value],
    ) -> Result<crate::rune::hydron::values::Value, crate::rune::hydron::values::EvalError> {
        use crate::rune::hydron::values::{EvalError, Value};

        if !self.cuda_available {
            return Err(EvalError::UnsupportedOperation(
                "CUDA not available on this system".to_string(),
            ));
        }

        match operation {
            "CudaDomR" | "CudaArchetypeDomR" => {
                // Extract energy array from first argument
                let energy_vec = extract_energy_array(&energy_args[0])?;
                let n_dr = energy_args.get(1)
                    .map(|v| extract_usize(v))
                    .transpose()?
                    .unwrap_or(8);

                #[cfg(feature = "cuda")]
                {
                    // Get the default hex graph
                    let graph = hex::default_graph();

                    // Compute scores using CUDA
                    let scores = curs::domr_scores_gpu(&energy_vec, graph.coords())
                        .map_err(|e| EvalError::InvalidOperation(format!("CUDA DomR failed: {}", e)))?;

                    if scores.len() != graph.coords().len() {
                        return Err(EvalError::InvalidOperation(
                            "CUDA returned mismatched score length".to_string(),
                        ));
                    }

                    // Sort by score descending and take top n_dr
                    let mut pairs: Vec<(usize, f32)> = scores.into_iter().enumerate().collect();
                    pairs.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

                    let take = n_dr.min(pairs.len());
                    let mut roots = Vec::with_capacity(take);
                    let mut out_scores = Vec::with_capacity(take);

                    for (idx, score) in pairs.into_iter().take(take) {
                        roots.push(idx as u8);
                        out_scores.push(score);
                    }

                    Ok(Value::DomR(hex::DomR {
                        roots,
                        scores: out_scores,
                    }))
                }

                #[cfg(not(feature = "cuda"))]
                {
                    Err(EvalError::UnsupportedOperation(
                        "CUDA feature not enabled".to_string(),
                    ))
                }
            }

            _ => Err(EvalError::UnsupportedOperation(format!(
                "Unknown CUDA operation: {} (only DomR operations supported)",
                operation
            ))),
        }
    }
}

impl Default for CudaAccelerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Global CUDA accelerator instance
static CUDA_ACCELERATOR: std::sync::OnceLock<CudaAccelerator> = std::sync::OnceLock::new();

/// Get or initialize the global CUDA accelerator
pub fn get_cuda_accelerator() -> &'static CudaAccelerator {
    CUDA_ACCELERATOR.get_or_init(|| CudaAccelerator::new())
}

// Helper functions for extracting values from Value enum

fn extract_energy_array(val: &crate::rune::hydron::values::Value) -> Result<Vec<f32>, crate::rune::hydron::values::EvalError> {
    use crate::rune::hydron::values::{EvalError, Value};

    match val {
        Value::Array(arr) => {
            if arr.len() != 240 {
                return Err(EvalError::TypeMismatch(format!(
                    "Energy array must have length 240, got {}",
                    arr.len()
                )));
            }
            arr.iter()
                .map(|v| extract_f32(v))
                .collect()
        }
        _ => Err(EvalError::TypeMismatch(
            "Energy argument must be an Array of 240 floats".to_string(),
        )),
    }
}

fn extract_f32(val: &crate::rune::hydron::values::Value) -> Result<f32, crate::rune::hydron::values::EvalError> {
    use crate::rune::hydron::values::{EvalError, Value};

    match val {
        Value::Scalar(f) => Ok(*f),
        Value::Float(f) => Ok(*f as f32),
        Value::Integer(i) => Ok(*i as f32),
        _ => Err(EvalError::TypeMismatch(
            "Value must be numeric (Scalar, Float, or Integer)".to_string(),
        )),
    }
}

fn extract_usize(val: &crate::rune::hydron::values::Value) -> Result<usize, crate::rune::hydron::values::EvalError> {
    use crate::rune::hydron::values::{EvalError, Value};

    match val {
        Value::Scalar(f) => Ok(*f as usize),
        Value::Float(f) => Ok(*f as usize),
        Value::Integer(i) => Ok(*i as usize),
        _ => Err(EvalError::TypeMismatch(
            "Index must be numeric".to_string(),
        )),
    }
}

File: hydron\eval.rs
====================
//! RUNE Expression Evaluator
//!
//! Evaluates RUNE expressions with semantic prefixes, array literals, and operators.
//! Supports mathematical operations, semantic type checking, and E8 geometry primitives.
//!
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use super::values::{EvalContext, EvalError, Value};
use crate::rune::ops::MathOp;
use crate::rune::{
    Expr, Ident, Literal, MathAtom, MathExpr, MathUnaryOp, RuneOp, SemanticIdent, Stmt, Term,
};
use std::collections::HashMap;

/// RUNE expression evaluator with semantic type support
pub struct Evaluator {
    /// Variable bindings (name -> value)
    variables: HashMap<String, Value>,
    /// Semantic namespace bindings (T:name -> value)
    semantic_vars: HashMap<String, Value>,
}

impl Evaluator {
    /// Create a new evaluator with empty context
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            semantic_vars: HashMap::new(),
        }
    }

    /// Create evaluator with pre-populated context
    pub fn with_context(ctx: EvalContext) -> Self {
        Self {
            variables: ctx.variables,
            semantic_vars: ctx.semantic_vars,
        }
    }

    /// Set a variable value
    pub fn set_var(&mut self, name: impl Into<String>, value: Value) {
        self.variables.insert(name.into(), value);
    }

    /// Set a semantic variable value (e.g., T:Gf8)
    pub fn set_semantic(&mut self, prefix: char, name: impl Into<String>, value: Value) {
        let key = format!("{}:{}", prefix, name.into());
        self.semantic_vars.insert(key, value);
    }

    /// Print SIMD capabilities (diagnostic)
    #[cfg(feature = "simd")]
    pub fn print_simd_info(&self) {
        use super::values::{get_available_f32_256_intrinsics, print_simd_capabilities};
        print_simd_capabilities();
        let intrinsics = get_available_f32_256_intrinsics();
        println!("Available f32x256 intrinsics: {:?}", intrinsics);
    }

    /// Get a variable value
    pub fn get_var(&self, name: &str) -> Option<&Value> {
        self.variables.get(name)
    }

    /// Get a semantic variable value
    pub fn get_semantic(&self, prefix: char, name: &str) -> Option<&Value> {
        let key = format!("{}:{}", prefix, name);
        self.semantic_vars.get(&key)
    }

    /// Evaluate a statement
    pub fn eval_stmt(&mut self, stmt: &Stmt) -> Result<Value, EvalError> {
        match stmt {
            Stmt::RootDecl(root) => {
                // Root declarations don't produce values, but we can store them as context
                Ok(Value::String(root.to_string()))
            }
            Stmt::ToonBlock { name, content } => {
                // TOON blocks are data, not computation - return the raw content
                Ok(Value::String(format!(
                    "TOON block '{}': {} chars",
                    name,
                    content.len()
                )))
            }
            Stmt::KernelDecl { name, archetype: _ } => {
                // Kernel declarations are declarations, not computations - return description
                Ok(Value::String(format!("Kernel '{}' declared", name.name.0)))
            }
            Stmt::Expr(expr) => self.eval_expr(expr),
        }
    }

    /// Evaluate a typed statement (StmtTyped), respecting the type annotations
    /// provided by the parser's inference pass.
    pub fn eval_typed_stmt(&mut self, stmt: &crate::rune::ast::StmtTyped) -> Result<Value, EvalError> {
        match stmt {
            crate::rune::ast::StmtTyped::RootDecl(root) => Ok(Value::String(root.to_string())),
            crate::rune::ast::StmtTyped::ToonBlock { name, content } => Ok(Value::String(format!(
                "TOON block '{}': {} chars",
                name,
                content.len()
            ))),
            crate::rune::ast::StmtTyped::KernelDecl { name, archetype: _ } => Ok(Value::String(format!("Kernel '{}' declared", name.name.0))),
            crate::rune::ast::StmtTyped::Expr(te) => {
                // For now, just evaluate the inner expression as before, type info is advisory.
                self.eval_expr(&te.expr)
            }
        }
    }

    /// Evaluate an expression
    pub fn eval_expr(&mut self, expr: &Expr) -> Result<Value, EvalError> {
        match expr {
            Expr::Term(term) => self.eval_term(term),
            Expr::Binary { left, op, right } => {
                // Special-case: transform operator `~` used as builtin invocation
                // e.g., `S7Slerp ~ [a, b, t]` where left is builtin name
                if *op == RuneOp::Transform {
                    // If left is a direct identifier, treat as builtin name
                    if let Expr::Term(Term::Ident(id)) = &**left {
                        // Evaluate the right expression to a value
                        let right_val = self.eval_expr(right)?;
                        // If right_val is an Array, use elements as args; otherwise a single arg
                        let args: Vec<Value> = match right_val {
                            Value::Array(arr) => arr,
                            v => vec![v],
                        };

                        // Dispatch to builtin
                        let ctx = self.context();
                        return ctx.apply_builtin_by_name(&id.0, &args);
                    }
                }

                let left_val = self.eval_expr(left)?;
                let right_val = self.eval_expr(right)?;
                self.eval_binary_op(&left_val, op, &right_val)
            }
        }
    }

    /// Evaluate a term
    fn eval_term(&self, term: &Term) -> Result<Value, EvalError> {
        match term {
            Term::Literal(lit) => self.eval_literal(lit),
            Term::Ident(ident) => self.eval_ident(ident),
            Term::SemanticIdent(sem) => self.eval_semantic_ident(sem),
            Term::Group(expr) => {
                // Group expressions are used for math blocks [expr]
                // For now, just evaluate the inner expression
                let mut temp_eval = Self {
                    variables: self.variables.clone(),
                    semantic_vars: self.semantic_vars.clone(),
                };
                temp_eval.eval_expr(expr)
            }
            Term::Math(math_expr) => {
                // Math blocks contain MathExpr which needs evaluation
                self.eval_math_expr(math_expr)
            }
            Term::FunctionCall { name, args } => {
                // Evaluate function call by dispatching to builtin
                let mut temp_eval = Self {
                    variables: self.variables.clone(),
                    semantic_vars: self.semantic_vars.clone(),
                };
                let args: Vec<Value> = args.iter().map(|arg| temp_eval.eval_expr(arg)).collect::<Result<_, _>>()?;
                let ctx = self.context();
                ctx.apply_builtin_by_name(&name.0, &args)
            }
        }
    }

    /// Evaluate a math expression
    fn eval_math_expr(&self, math: &MathExpr) -> Result<Value, EvalError> {
        match math {
            MathExpr::Atom(atom) => self.eval_math_atom(atom),
            MathExpr::Binary { left, op, right } => {
                let left_val = self.eval_math_expr(left)?;
                let right_val = self.eval_math_expr(right)?;
                self.eval_math_op(&left_val, op, &right_val)
            }
            MathExpr::Unary { op, operand } => {
                let val = self.eval_math_expr(operand)?;
                self.eval_math_unary_op(op, &val)
            }
        }
    }

    /// Evaluate a math atom
    fn eval_math_atom(&self, atom: &MathAtom) -> Result<Value, EvalError> {
        match atom {
            MathAtom::Number(n) => Ok(Value::Float(*n)),
            MathAtom::Ident(ident) => {
                // Check if it's a semantic identifier (contains ':')
                if ident.0.contains(':') {
                    let parts: Vec<&str> = ident.0.split(':').collect();
                    if parts.len() == 2 && parts[0].len() == 1 {
                        let prefix = parts[0].chars().next().unwrap();
                        self.get_semantic(prefix, parts[1])
                            .cloned()
                            .ok_or_else(|| EvalError::UndefinedVariable(ident.0.clone()))
                    } else {
                        self.eval_ident(ident)
                    }
                } else {
                    self.eval_ident(ident)
                }
            }
            MathAtom::Group(math) => self.eval_math_expr(math),
            MathAtom::Array(elements) => {
                // Evaluate array literal inside math block
                let mut values = Vec::new();
                for elem in elements {
                    values.push(self.eval_math_expr(elem)?);
                }
                Ok(Value::Array(values))
            }
        }
    }

    /// Evaluate a math binary operation
    fn eval_math_op(&self, left: &Value, op: &MathOp, right: &Value) -> Result<Value, EvalError> {
        match op {
            MathOp::Add => left.add(right),
            MathOp::Subtract => left.sub(right),
            MathOp::Multiply => left.mul(right),
            MathOp::Divide => left.div(right),
            MathOp::Power => left.pow(right),
            MathOp::Modulo => left.modulo(right),
            MathOp::Root => Err(EvalError::UnsupportedOperation(
                "Root operator not yet implemented".into(),
            )),
        }
    }

    /// Evaluate a math unary operation
    fn eval_math_unary_op(&self, op: &MathUnaryOp, val: &Value) -> Result<Value, EvalError> {
        match op {
            MathUnaryOp::Negate => val.negate(),
            MathUnaryOp::Plus => Ok(val.clone()),
        }
    }

    /// Evaluate a literal value
    fn eval_literal(&self, lit: &Literal) -> Result<Value, EvalError> {
        match lit {
            Literal::Number(n) => Ok(Value::Float(*n)),
            Literal::String(s) => Ok(Value::String(s.clone())),
            Literal::Bool(b) => Ok(Value::Scalar(if *b { 1.0 } else { 0.0 })),
            Literal::Array(exprs) => {
                let mut values = Vec::new();
                let mut temp_eval = Self {
                    variables: self.variables.clone(),
                    semantic_vars: self.semantic_vars.clone(),
                };
                for expr in exprs {
                    values.push(temp_eval.eval_expr(expr)?);
                }
                Ok(Value::Array(values))
            }
        }
    }

    /// Evaluate an identifier (variable lookup)
    fn eval_ident(&self, ident: &Ident) -> Result<Value, EvalError> {
        self.variables
            .get(&ident.0)
            .cloned()
            .ok_or_else(|| EvalError::UndefinedVariable(ident.0.clone()))
    }

    /// Evaluate a semantic identifier (T:name, V:velocity, etc.)
    fn eval_semantic_ident(&self, sem: &SemanticIdent) -> Result<Value, EvalError> {
        let key = format!("{}:{}", sem.prefix, sem.name.0);
        self.semantic_vars
            .get(&key)
            .cloned()
            .ok_or_else(|| EvalError::UndefinedVariable(key))
    }

    /// Evaluate a binary operation using RuneOp (structural operations only)
    /// Arithmetic operations are handled by MathOp within math blocks `[]`
    fn eval_binary_op(&self, left: &Value, op: &RuneOp, right: &Value) -> Result<Value, EvalError> {
        use RuneOp::*;

        match op {
            // Comparison operators
            Less => left.lt(right),
            LessEqual => left.le(right),
            Greater => left.gt(right),
            GreaterEqual => left.ge(right),
            Equal => Ok(Value::Bool(left == right)),

            // Structural operators (not for computation) - arithmetic handled by MathOp
            Descendant | Ancestor | Define | FlowRight | FlowLeft | Bind | Namespace | Alias
            | Parallel | Transform | SplitJoin | JoinSplit | AnchorDescend | BranchStabilize
            | RootStabilize | StabilizeRoot | SymmetricSplit | BranchAnchorBranch
            | Specializes | Match | Unify | FlowBidirectional | FlowConvergent
            | PipelineRight | PipelineLeft | Output | Input => {
                Err(EvalError::UnsupportedOperation(format!(
                    "Structural operator {:?} not implemented for computation. Use math blocks `[]` for arithmetic.",
                    op
                )))
            }
        }
    }

    /// Export current context
    pub fn context(&self) -> EvalContext {
        let mut ctx = EvalContext::new();
        for (name, value) in &self.variables {
            ctx.bind(name.clone(), value.clone());
        }
        // Add semantic variables from the evaluator into the context so builtins
        // can resolve semantic identifiers.
        for (k, v) in &self.semantic_vars {
            ctx.semantic_vars.insert(k.clone(), v.clone());
        }
        ctx
    }

    /// Evaluate a builtin by its textual name using the current context
    pub fn eval_builtin_by_name(
        &self,
        name: &str,
        args: &[Value],
    ) -> Result<Value, EvalError> {
        let ctx = self.context();
        ctx.apply_builtin_by_name(name, args)
    }
}

impl Default for Evaluator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::rune::parse;

    #[test]
    fn test_eval_literal_number() {
        let mut eval = Evaluator::new();
        let stmts = parse("42").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(42.0));
    }

    #[test]
    fn test_eval_arithmetic() {
        let mut eval = Evaluator::new();

        // Simple addition in math block
        let stmts = parse("[2 + 3]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(5.0));

        // Multiplication in math block
        let stmts = parse("[4 * 5]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(20.0));

        // Complex expression with precedence
        let stmts = parse("[2 + 3 * 4]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(14.0)); // Respects precedence

        // Division in math block
        let stmts = parse("[10 / 2]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(5.0));

        // Power in math block
        let stmts = parse("[2 ^ 3]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(8.0));

        // Modulo in math block
        let stmts = parse("[10 % 3]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(1.0));
    }

    #[test]
    fn test_eval_array_literal() {
        let mut eval = Evaluator::new();
        let stmts = parse("[1, 2, 3]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();

        match result {
            Value::Array(arr) => {
                assert_eq!(arr.len(), 3);
                assert_eq!(arr[0], Value::Float(1.0));
                assert_eq!(arr[1], Value::Float(2.0));
                assert_eq!(arr[2], Value::Float(3.0));
            }
            _ => panic!("Expected array value"),
        }
    }

    #[test]
    fn test_eval_array_operations() {
        let mut eval = Evaluator::new();

        // Array addition (element-wise) in math block
        let stmts = parse("[[1, 2, 3] + [4, 5, 6]]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();

        match result {
            Value::Array(arr) => {
                assert_eq!(arr.len(), 3);
                assert_eq!(arr[0], Value::Float(5.0));
                assert_eq!(arr[1], Value::Float(7.0));
                assert_eq!(arr[2], Value::Float(9.0));
            }
            _ => panic!("Expected array value"),
        }
    }

    #[test]
    fn test_eval_semantic_prefix() {
        let mut eval = Evaluator::new();

        // Set semantic variable
        eval.set_semantic('T', "Gf8", Value::Float(2.5));

        // Evaluate semantic expression in math block
        let stmts = parse("[T:Gf8 * 3]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(7.5));
    }

    #[test]
    fn test_eval_variables() {
        let mut eval = Evaluator::new();

        // Set variable
        eval.set_var("x", Value::Float(10.0));

        // Use in expression within math block
        let stmts = parse("[x + 5]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(15.0));
    }

    #[test]
    fn test_eval_nested_math() {
        let mut eval = Evaluator::new();

        // Math block with nested operations
        let stmts = parse("[[3, 3, 3] * [2, 2, 2]]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();

        match result {
            Value::Array(arr) => {
                assert_eq!(arr.len(), 3);
                assert_eq!(arr[0], Value::Float(6.0));
                assert_eq!(arr[1], Value::Float(6.0));
                assert_eq!(arr[2], Value::Float(6.0));
            }
            _ => panic!("Expected array value"),
        }
    }

    #[test]
    fn test_eval_comparison() {
        let mut eval = Evaluator::new();

        // Comparisons work with RuneOp outside math blocks
        let stmts = parse("5 > 3").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(true));

        let stmts = parse("2 = 2").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(true));
    }

    #[test]
    fn test_eval_unary_minus() {
        let mut eval = Evaluator::new();

        // Unary minus in math block
        let stmts = parse("[-5]").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Float(-5.0));
    }

    #[test]
    fn test_eval_comparison_operators() {
        let mut eval = Evaluator::new();

        // Test less than or equal
        let stmts = parse("3 <= 5").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(true));

        let stmts = parse("5 <= 5").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(true));

        let stmts = parse("7 <= 5").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(false));

        // Test greater than or equal
        let stmts = parse("5 >= 3").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(true));

        let stmts = parse("5 >= 5").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(true));

        let stmts = parse("3 >= 5").unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        assert_eq!(result, Value::Bool(false));
    }

    #[test]
    fn test_eval_builtin_by_name() {
        let eval = Evaluator::new();
        let a = crate::rune::hydron::values::Value::Vec8([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        let b = crate::rune::hydron::values::Value::Vec8([0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        // Use static method eval_builtin_by_name to invoke S7Distance
        let result = eval.eval_builtin_by_name("S7Distance", &[a.clone(), b.clone()]).unwrap();
        assert!(matches!(result, crate::rune::hydron::values::Value::Scalar(_)));

        // Slerp interception
        let t = crate::rune::hydron::values::Value::Scalar(0.5);
        let interp = eval
            .eval_builtin_by_name("S7Slerp", &[a.clone(), b.clone(), t])
            .unwrap();
        assert!(matches!(interp, crate::rune::hydron::values::Value::Vec8(_)));
    }

    #[test]
    fn test_parse_typed_and_eval() {
        let mut eval = Evaluator::new();
        // parse typed statement
        let typed = crate::rune::parse_typed("[2 + 3]").unwrap();
        assert_eq!(typed.len(), 1);
        if let crate::rune::ast::StmtTyped::Expr(te) = &typed[0] {
            // Type should be Scalar
            assert_eq!(te.r#type, crate::rune::ast::RuneType::Scalar);
            let result = eval.eval_typed_stmt(&typed[0]).unwrap();
            assert_eq!(result, crate::rune::hydron::values::Value::Float(5.0));
        } else {
            panic!("Expected typed expr");
        }
    }

    #[test]
    fn test_eval_transform_builtin_slerp() {
        let mut eval = Evaluator::new();
        let script = "S7Slerp ~ [[1,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0], 0.5]";
        let stmts = crate::rune::parse(script).unwrap();
        let result = eval.eval_stmt(&stmts[0]).unwrap();
        // Expect Vec8 result
        assert!(matches!(result, crate::rune::hydron::values::Value::Vec8(_)));
    }
}

File: hydron\mod.rs
===================
//! Hydron - E8 Geometric Mathematics Engine
//!
//! Pure mathematical implementations of E8 lattice geometry with multi-geometric layers:
//! - Fisher information geometry (statistical manifolds)
//! - Symplectic T*E8 geometry (Hamiltonian dynamics)
//! - Hyperbolic H8 geometry (Poincaré ball model)
//! - Topological analysis (persistent homology)
//! - Lorentzian geometry (spacetime metrics)
//! - Quaternion algebra (rotations, SLERP)
//! - Spherical S7 geometry (unit sphere)
//!
//! All modules provide pure geometric operations. Application-specific extensions
//! (e.g., causal DAGs, event systems) are clearly separated.
//!
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

#[cfg(feature = "cuda")]
pub mod cuda;
pub mod eval;
pub mod perception;
pub mod topology;
pub mod values;

// Re-export the hydron-core crate's math modules when the feature is enabled.
// This keeps the Rune crate's public API stable while the actual math is
// implemented in the `hydron-core` crate.
#[cfg(feature = "hydron")]
pub use hydron_core::{
    FisherLayer, Gf8, Gf8Tensor, HyperbolicLayer, LorentzianCausalLayer, LorentzianLayer,
    PersistencePair, QuaternionOps, SpacetimePoint, SphericalLayer, SymplecticLayer,
    TopologicalLayer, intrinsics_for_f32_width,
};

// When hydron feature is disabled, keep local types for the evaluator and values as-is.
// Re-export the runtime value types so code can always import `crate::rune::hydron::Value`.
pub use crate::rune::hydron::values::{EvalContext, EvalError, Octonion, Value};

File: hydron\topology.rs
========================
//! E8 Topology & Weyl Group Operations.
//!
//! # Hydron – Topology Module
//! ▫~•◦------------------------‣
//!
//! Provides adjacency (kissing) relations, Weyl reflections, and simple diffusion over
//! the E8 root lattice. Uses the static root table from hydron-core.
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use hydron_core::get_e8_roots;

/// Returns the indices of the 56 nearest neighbors in the E8 lattice.
/// Roots are neighbors if their dot product is approximately 0.5 (60 degrees).
pub fn get_neighbors(root_idx: usize) -> Vec<u8> {
    let roots = get_e8_roots();
    if root_idx >= roots.len() {
        return vec![];
    }
    let target = roots[root_idx];
    let mut neighbors = Vec::with_capacity(56);

    for (i, root) in roots.iter().enumerate() {
        if i == root_idx {
            continue;
        }
        let dot: f32 = target.iter().zip(root.iter()).map(|(a, b)| a * b).sum();
        if (dot - 0.5).abs() < 1e-4 {
            neighbors.push(i as u8);
        }
    }
    neighbors
}

/// Performs a Weyl reflection of a vector `v` across the hyperplane orthogonal to root `r`.
/// Formula (unit roots): v' = v - 2 * <v, r> * r
pub fn weyl_reflect(vec: &[f32; 8], mirror_root: &[f32; 8]) -> [f32; 8] {
    let dot: f32 = vec.iter().zip(mirror_root.iter()).map(|(a, b)| a * b).sum();
    let mut result = [0.0; 8];
    for i in 0..8 {
        result[i] = vec[i] - 2.0 * dot * mirror_root[i];
    }
    result
}

/// Diffuse energy over the E8 lattice (swarm/attention style).
/// Keeps source energy and adds a fraction to neighbors.
pub fn diffuse_energy(energy: &[f32; 240], diffusion_rate: f32) -> [f32; 240] {
    let _roots = get_e8_roots();
    let mut new_field = *energy;

    for i in 0..240 {
        let e = energy[i];
        if e <= 1e-6 {
            continue;
        }
        let neighbors = get_neighbors(i);
        if neighbors.is_empty() {
            continue;
        }
        let flow = e * diffusion_rate;
        let flow_per = flow / neighbors.len() as f32;
        for n in neighbors {
            new_field[n as usize] += flow_per;
        }
    }

    new_field
}

File: parts\arrays.rs
=====================
#[cfg(feature = "hydron")]
use crate::encode_default;
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;

#[cfg(not(feature = "hydron"))]
pub fn arrays() {
    println!("Hydron feature required for dynamic arrays");
}

#[cfg(feature = "hydron")]
pub fn arrays() {
    // Dynamic Array (Strings)
    let tags = Value::Array(vec![
        Value::String("admin".to_string()),
        Value::String("ops".to_string()),
        Value::String("dev".to_string()),
    ]);
    let out = encode_default(&tags).unwrap();
    println!("tags[3]: {out}");

    // Dynamic Array (Numbers)
    let nums = Value::Array(vec![
        Value::Integer(1),
        Value::Integer(2),
        Value::Integer(3),
        Value::Integer(4),
        Value::Integer(5),
    ]);
    let out = encode_default(&nums).unwrap();
    println!("\nnums[5]: {out}");

    // Dynamic Array (Mixed)
    let mixed = Value::Array(vec![
        Value::String("x".to_string()),
        Value::String("y".to_string()),
        Value::Bool(true),
        Value::Integer(10),
    ]);
    let out = encode_default(&mixed).unwrap();
    println!("\ndata[4]: {out}");
}

File: parts\arrays_of_arrays.rs
===============================
#[cfg(feature = "hydron")]
use crate::encode_default;
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn arrays_of_arrays() {
    println!("Hydron feature required for dynamic arrays of arrays");
}

#[cfg(feature = "hydron")]
pub fn arrays_of_arrays() {
    // Dynamic Arrays of Arrays (Integers)
    let pair1 = Value::Array(vec![Value::Integer(1), Value::Integer(2)]);
    let pair2 = Value::Array(vec![Value::Integer(3), Value::Integer(4)]);
    let pairs_array = Value::Array(vec![pair1, pair2]);

    let mut pairs_map = HashMap::new();
    pairs_map.insert("pairs".to_string(), pairs_array);
    let pairs = Value::Map(pairs_map);

    let out = encode_default(&pairs).unwrap();
    println!("{out}");

    // Dynamic Arrays of Arrays (Strings)
    let spair1 = Value::Array(vec![
        Value::String("a".to_string()),
        Value::String("b".to_string()),
    ]);
    let spair2 = Value::Array(vec![
        Value::String("c".to_string()),
        Value::String("d".to_string()),
    ]);
    let spairs_array = Value::Array(vec![spair1, spair2]);

    let mut spairs_map = HashMap::new();
    spairs_map.insert("pairs".to_string(), spairs_array);
    let string_pairs = Value::Map(spairs_map);

    let out = encode_default(&string_pairs).unwrap();
    println!("\n{out}");

    // Dynamic Matrix
    let row1 = Value::Array(vec![
        Value::Float(1.0),
        Value::Float(2.0),
        Value::Float(3.0),
    ]);
    let row2 = Value::Array(vec![
        Value::Float(4.0),
        Value::Float(5.0),
        Value::Float(6.0),
    ]);
    let row3 = Value::Array(vec![
        Value::Float(7.0),
        Value::Float(8.0),
        Value::Float(9.0),
    ]);
    let matrix_array = Value::Array(vec![row1, row2, row3]);

    let mut matrix_map = HashMap::new();
    matrix_map.insert("matrix".to_string(), matrix_array);
    let matrix = Value::Map(matrix_map);

    let out = encode_default(&matrix).unwrap();
    println!("\n{out}");
}

File: parts\decode_strict.rs
============================
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use crate::{DecodeOptions, decode};

#[cfg(not(feature = "hydron"))]
pub fn decode_strict() {
    println!("Hydron feature required for dynamic decode strict");
}

#[cfg(feature = "hydron")]
pub fn decode_strict() {
    // Malformed: header says 2 rows, but only 1 provided
    let malformed = "items[2]{id,name}:\n  1,Ada";

    let opts = DecodeOptions::new().with_strict(true);
    match decode::<Value>(malformed, &opts) {
        Ok(val) => println!("Unexpectedly decoded: {:?}", val),
        Err(err) => println!("Strict decode error: {err}"),
    }
}

File: hydron\perception.rs
==========================
/* src/rune/hydron/perception.rs */
//! Perception Engine: Signal (ByteLex) and Structure (Morphology) analysis.
//!
//! # Hydron – Perception Module
//!▫~•◦--------------------------‣
//!
//! This module provides the core mechanisms to convert raw text into geometric vectors
//! based on two distinct properties within the RUNE ecosystem, using zero external dependencies:
//!
//! 1.  **Signal (The Body):** Raw byte-level convolution using deterministic hashing.
//!     Captures "shape", typos, and non-linguistic patterns. Implemented via `signal_encode`.
//! 2.  **Structure (The Skeleton):** Morphological decomposition (Prefix/Root/Suffix).
//!     Captures linguistic logic and semantic composition. Implemented via `morph_analyze`.
//!
//! These vectors are designed to be fused (via `/\`) to create a lossless,
//! holographic embedding of the input.
//!
//! ### Key Capabilities
//! - **Signal Encoding:** Deterministic byte-stream convolution into normalized 8D vectors.
//! - **Morphological Analysis:** Greedy affix decomposition into geometric representations.
//! - **Root Recognition:** Common root validation against a curated lexicon for semantic anchoring.
//! - **Zero Dependencies:** All logic implemented using const-time hashing and static affix tables.
//!
//! ### Architectural Notes
//! This module is designed for integration with the broader RUNE/Hydron geometry pipeline.
//! Vectors produced here are normalized to the unit sphere (S7-compatible) and can be
//! composed using geometric algebra operations.
//!
//! ### Example
//! ```rust
//! use rune_format::rune::hydron::perception::{signal_encode, morph_analyze};
//!
//! let bytes = b"unbelievably";
//! let signal_vec = signal_encode(bytes);
//! let morph_vec = morph_analyze("unbelievably");
//!
//! // Both vectors are normalized and ready for geometric composition.
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

// --- 1. STATIC DATA (The Skeleton) ---
// High-coverage English affixes ported from the original lexicon architecture.
// These allow the engine to "see" word structure without a dictionary.

/// Comprehensive prefix table for morphological decomposition.
/// Ordered alphabetically for binary search compatibility.
/// Includes productive derivational and inflectional prefixes from Latin, Greek, and Germanic roots.
static PREFIXES: &[&str] = &[
    "a", "ab", "abs", "ac", "ad", "af", "ag", "al", "am", "an", "ante", "anti", "ap", "apo",
    "arch", "as", "at", "auto", "be", "bi", "bio", "cata", "circum", "cis", "co", "col", "com",
    "con", "contra", "cor", "counter", "de", "deca", "deci", "demi", "di", "dia", "dif", "dis",
    "down", "duo", "dys", "e", "ec", "eco", "ecto", "ef", "electro", "em", "en", "endo", "epi",
    "equi", "ex", "exo", "extra", "fore", "geo", "hemi", "hetero", "hexa", "homo", "hydro",
    "hyper", "hypo", "il", "im", "in", "infra", "inter", "intra", "intro", "ir", "iso", "kilo",
    "macro", "mal", "mega", "meta", "micro", "mid", "milli", "mini", "mis", "mono", "multi",
    "nano", "neo", "neuro", "non", "ob", "oc", "oct", "octa", "of", "omni", "op", "ortho", "out",
    "over", "paleo", "pan", "para", "penta", "per", "peri", "photo", "poly", "post", "pre",
    "preter", "pro", "proto", "pseudo", "pyro", "quadr", "quasi", "re", "retro", "self", "semi",
    "sept", "sex", "sub", "suc", "suf", "sug", "sum", "sup", "super", "sur", "sus", "sym", "syn",
    "tele", "tetra", "thermo", "trans", "tri", "twi", "ultra", "un", "under", "uni", "up", "vice",
];

/// Comprehensive suffix table for morphological decomposition.
/// Ordered alphabetically for binary search compatibility.
/// Includes productive derivational and inflectional suffixes across major word classes.
static SUFFIXES: &[&str] = &[
    "able",
    "ably",
    "ac",
    "aceous",
    "acious",
    "age",
    "al",
    "algia",
    "an",
    "ance",
    "ancy",
    "ant",
    "ar",
    "ard",
    "ary",
    "ase",
    "ate",
    "ation",
    "ative",
    "ator",
    "atory",
    "cide",
    "cracy",
    "crat",
    "cy",
    "dom",
    "dox",
    "ed",
    "ee",
    "eer",
    "en",
    "ence",
    "ency",
    "ent",
    "eous",
    "er",
    "ern",
    "ery",
    "es",
    "ese",
    "esque",
    "ess",
    "est",
    "etic",
    "ette",
    "ful",
    "fy",
    "gen",
    "genic",
    "gon",
    "gram",
    "graph",
    "graphy",
    "hood",
    "ia",
    "ial",
    "ian",
    "iasis",
    "iatric",
    "iatry",
    "ible",
    "ibly",
    "ic",
    "ical",
    "ically",
    "ice",
    "ician",
    "ics",
    "id",
    "ide",
    "ie",
    "ier",
    "iferous",
    "ific",
    "ification",
    "ify",
    "ile",
    "ine",
    "ing",
    "ion",
    "ior",
    "ious",
    "ish",
    "ism",
    "ist",
    "istic",
    "ite",
    "itis",
    "itive",
    "ity",
    "ium",
    "ive",
    "ize",
    "kin",
    "less",
    "let",
    "like",
    "ling",
    "logue",
    "logy",
    "ly",
    "lysis",
    "lyte",
    "lytic",
    "man",
    "mancy",
    "mania",
    "ment",
    "meter",
    "metry",
    "most",
    "ness",
    "oid",
    "ology",
    "oma",
    "or",
    "ory",
    "ose",
    "osis",
    "ous",
    "path",
    "pathy",
    "ped",
    "phage",
    "phagy",
    "phile",
    "philia",
    "phobe",
    "phobia",
    "phone",
    "phony",
    "phyte",
    "plasty",
    "pod",
    "polis",
    "proof",
    "ry",
    "s",
    "scope",
    "scopy",
    "sect",
    "ship",
    "sion",
    "sis",
    "some",
    "sophy",
    "ster",
    "th",
    "tion",
    "tomy",
    "tor",
    "tous",
    "trix",
    "tron",
    "tude",
    "ty",
    "ular",
    "ule",
    "ure",
    "ward",
    "wards",
    "wise",
    "woman",
    "worthy",
    "y",
    "yer",
];

/// Common etymological roots for semantic anchoring.
/// These high-frequency roots provide validation and boost morphological confidence.
/// Organized by semantic domain for future extensibility.
///
/// **Design Rationale:**
/// Rather than storing all possible roots (which would balloon the binary), we include
/// productive roots that appear across multiple derived forms. This allows the morphology
/// engine to recognize when a decomposition has landed on a "real" root vs. arbitrary residue.
static ROOTS: &[&str] = &[
    // --- Motion & Position ---
    "cede", "ceed", "cess", "cur", "curr", "curs", "duc", "duct", "fer", "gress", "ject", "miss",
    "mit", "mov", "mot", "pass", "ped", "pod", "port", "pos", "puls", "sequ", "spec", "spect",
    "sta", "stat", "tend", "tens", "tent", "tract", "vene", "vent", "vert", "vers", "via", "voy",
    // --- Perception & Cognition ---
    "audi", "audit", "cept", "ceive", "cogn", "cred", "dic", "dict", "log", "mem", "ment", "not",
    "path", "pens", "phon", "pict", "sci", "scrib", "script", "sens", "sent", "sign", "soph",
    "spec", "vid", "vis", // --- Action & Creation ---
    "cre", "creat", "fac", "fact", "fect", "fic", "fig", "form", "gen", "oper", "plic", "ply",
    "pon", "pos", "scrib", "struct", "tain", "ten", "volv",
    // --- Communication & Expression ---
    "claim", "clam", "loqu", "locut", "nounce", "nunce", "parl", "phan", "phone", "voc", "voic",
    "voke", // --- Measurement & Science ---
    "centr", "chron", "cycl", "dyna", "graph", "gram", "hydr", "log", "metr", "meter", "morph",
    "nym", "phys", "scop", "sphere", "techn", "therm", // --- Social & Legal ---
    "civ", "dem", "jud", "jur", "jus", "leg", "liber", "poli", "polit", "popul", "reg", "soci",
    // --- Life & Nature ---
    "anim", "anthrop", "bio", "corp", "geo", "herb", "viv", "zoo",
    // --- Emotion & Value ---
    "am", "amor", "bene", "bon", "fort", "grat", "mal", "magn", "misc", "pac", "pat", "phil",
    "vict", "vinc", // --- Quantity & Relation ---
    "equ", "fin", "fract", "frag", "grad", "gress", "medi", "min", "mit", "multi", "nom", "plen",
    "plu", "plus", "simil", "sing", "sol", "uni", "vac", "van", "void",
    // --- Time & Change ---
    "aev", "chron", "dur", "gener", "nov", "prim", "temp", "vest",
    // --- Quality & State ---
    "acer", "acr", "acu", "alb", "alt", "clar", "dign", "dur", "firm", "fort", "grav", "lev",
    "liber", "lucid", "nigr", "prob", "purg", "sacr", "san", "satis", "secur", "serv", "sever",
    "simpl", "stabil", "strict", "triv", "turb", "urb", "util", "vag", "val", "var", "ver",
    "vigil",
];

// --- 2. MATH KERNEL (Deterministic Hashing) ---

/// SplitMix64: Fast, dependency-free pseudo-random hashing.
/// Used to project arbitrary bytes into the 8D geometric space deterministically.
///
/// # Invariants
/// - Same input always produces same output (deterministic).
/// - Output has high avalanche properties (single-bit changes propagate).
///
/// # Arguments
/// * `x` - Seed value for the hash.
///
/// # Returns
/// * `u64` - The hashed value.
#[inline]
const fn splitmix64(mut x: u64) -> u64 {
    x = x.wrapping_add(0x9E3779B97F4A7C15);
    let mut z = x;
    z = (z ^ (z >> 30)).wrapping_mul(0xBF58476D1CE4E5B9);
    z = (z ^ (z >> 27)).wrapping_mul(0x94D049BB133111EB);
    z ^ (z >> 31)
}

/// Map a hash seed to a unit float within [-0.5, 0.5).
/// This centers the signal around the origin, ideal for geometric composition.
///
/// # Arguments
/// * `seed` - The hash seed to convert.
///
/// # Returns
/// * `f32` - A floating-point value in the range [-0.5, 0.5).
#[inline]
fn hash_to_float(seed: u64) -> f32 {
    let bits = splitmix64(seed);
    let as_f64 = (bits >> 11) as f64 * (1.0 / (1u64 << 53) as f64);
    (as_f64 as f32) - 0.5
}

// --- 3. SIGNAL ENCODING (The Body) ---

/// Encodes raw bytes into an 8D semantic vector using strided convolution.
///
/// This function treats the byte stream as a continuous signal, applying a local
/// convolution window and pooling the result into a normalized vector. Each byte
/// contributes to all 8 dimensions based on its value and position, creating a
/// holographic representation of the input.
///
/// # Algorithmic Details
/// - **Window Size:** Minimum of 4 or the input length, providing local context.
/// - **Position Encoding:** Modulo-based positional hashing ensures location-awareness.
/// - **Normalization:** Result is projected onto the unit sphere (L2 norm = 1.0).
///
/// # Arguments
/// * `bytes` - The raw input byte stream.
///
/// # Returns
/// * `[f32; 8]` - The normalized signal vector. Returns zero vector for empty input.
#[inline]
pub fn signal_encode(bytes: &[u8]) -> [f32; 8] {
    if bytes.is_empty() {
        return [0.0; 8];
    }

    let mut signal = [0.0f32; 8];
    let window_size = 4.min(bytes.len());

    for (i, &b) in bytes.iter().enumerate() {
        for dim in 0..8 {
            let seed = (b as u64)
                .wrapping_mul(31)
                .wrapping_add(dim as u64)
                .wrapping_add((i % window_size) as u64 * 1024);

            let val = hash_to_float(seed);
            signal[dim] += val;
        }
    }

    let norm_sq: f32 = signal.iter().map(|x| x * x).sum();
    if norm_sq > 1e-9 {
        let inv_norm = 1.0 / norm_sq.sqrt();
        for x in &mut signal {
            *x *= inv_norm;
        }
    }

    signal
}

// --- 4. STRUCTURE ANALYSIS (The Skeleton) ---

/// Validate if a potential root exists in the known root lexicon.
/// Uses binary search for O(log n) lookup.
///
/// # Arguments
/// * `candidate` - The root candidate to validate.
///
/// # Returns
/// * `bool` - True if the candidate is a recognized root.
#[inline]
fn is_valid_root(candidate: &str) -> bool {
    ROOTS.iter().any(|&r| r == candidate)
}

/// Analyze string morphology and return a structural hash vector.
///
/// This function decomposes a token into `<prefix>`, `<root>`, `<suffix>` using a
/// greedy longest-match algorithm against static affix tables. The root is validated
/// against a curated lexicon to ensure semantic anchoring. Each component is then
/// hashed into an 8D vector space with distinct seed offsets to prevent collisions.
///
/// # Enhanced Root Recognition
/// After affix stripping, the remaining root is checked against `ROOTS`. If the root
/// is unrecognized but longer than 3 characters, the algorithm attempts progressive
/// suffix stripping to find a valid root kernel. This handles cases like:
/// - "believe" → valid root (recognized)
/// - "believing" → "believ" + "ing" → fallback checks "belie", "beli", "bel" until match or exhaustion
///
/// # Arguments
/// * `token` - The input token to analyze.
///
/// # Returns
/// * `[f32; 8]` - The normalized morphology vector.
#[inline]
pub fn morph_analyze(token: &str) -> [f32; 8] {
    let clean = token
        .trim_matches(|c: char| !c.is_alphanumeric())
        .to_lowercase();

    if clean.is_empty() {
        return [0.0; 8];
    }

    let mut prefix = "";
    let mut suffix = "";
    let mut root = clean.as_str();

    // Identify prefix (greedy longest match)
    for &p in PREFIXES {
        if root.starts_with(p) && root.len() > p.len() + 2 {
            if p.len() > prefix.len() {
                prefix = p;
            }
        }
    }

    if !prefix.is_empty() {
        root = &root[prefix.len()..];
    }

    // Identify suffix (greedy longest match)
    for &s in SUFFIXES {
        if root.ends_with(s) && root.len() > s.len() + 2 {
            if s.len() > suffix.len() {
                suffix = s;
            }
        }
    }

    if !suffix.is_empty() {
        root = &root[..root.len() - suffix.len()];
    }

    // Root validation & progressive kernel extraction
    if !is_valid_root(root) && root.len() > 3 {
        // Attempt progressive stripping to find a valid root kernel
        // Example: "running" → root "run" after "n" → "ing" decomposition
        let mut candidate = root;
        while candidate.len() > 2 {
            if is_valid_root(candidate) {
                root = candidate;
                break;
            }
            // Strip one character from the end
            candidate = &candidate[..candidate.len() - 1];
        }
    }

    // Hash the components into the 8D vector
    let mut vec = [0.0f32; 8];

    let components = [
        (prefix, 100u64), // Prefix offset
        (root, 0u64),     // Root offset
        (suffix, 200u64), // Suffix offset
    ];

    for (str_part, seed_offset) in components {
        if str_part.is_empty() {
            continue;
        }

        for (i, &b) in str_part.as_bytes().iter().enumerate() {
            for dim in 0..8 {
                let seed = (b as u64)
                    .wrapping_add(dim as u64)
                    .wrapping_add(i as u64 * 31)
                    .wrapping_add(seed_offset);

                vec[dim] += hash_to_float(seed);
            }
        }
    }

    let norm_sq: f32 = vec.iter().map(|x| x * x).sum();
    if norm_sq > 1e-9 {
        let inv_norm = 1.0 / norm_sq.sqrt();
        for x in &mut vec {
            *x *= inv_norm;
        }
    }

    vec
}

#[cfg(test)]
mod tests {
    use super::{hash_to_float, is_valid_root, morph_analyze, signal_encode, splitmix64};

    #[test]
    fn test_signal_encode_determinism() {
        let input = b"hello world";
        let v1 = signal_encode(input);
        let v2 = signal_encode(input);
        assert_eq!(v1, v2, "Signal encoding must be deterministic");

        let v3 = signal_encode(b"hello worl");
        let dot: f32 = v1.iter().zip(v3.iter()).map(|(a, b)| a * b).sum();
        assert!(
            dot > 0.8,
            "Similar strings should have high signal correlation"
        );
        assert!(dot < 0.9999, "Distinct strings should not be identical");
    }

    #[test]
    fn test_signal_encode_empty_input() {
        let vec = signal_encode(b"");
        assert_eq!(vec, [0.0; 8], "Empty input should produce zero vector");
    }

    #[test]
    fn test_signal_encode_normalization() {
        let vec = signal_encode(b"test");
        let norm: f32 = vec.iter().map(|x| x * x).sum::<f32>().sqrt();
        assert!(
            (norm - 1.0).abs() < 1e-5,
            "Signal vector must be normalized"
        );
    }

    #[test]
    fn test_morph_analyze_decomposition() {
        let v1 = morph_analyze("unbelievably");
        let v2 = morph_analyze("believer");

        let dot: f32 = v1.iter().zip(v2.iter()).map(|(a, b)| a * b).sum();
        assert!(
            dot > 0.0,
            "Shared roots should produce positive correlation"
        );
    }

    #[test]
    fn test_morph_analyze_affix_handling() {
        let v_redo = morph_analyze("redo");
        let v_do = morph_analyze("do");

        assert_ne!(v_redo, v_do, "Prefix presence should alter the vector");
    }

    #[test]
    fn test_morph_analyze_empty_input() {
        let vec = morph_analyze("");
        assert_eq!(vec, [0.0; 8], "Empty input should produce zero vector");
    }

    #[test]
    fn test_morph_analyze_normalization() {
        let vec = morph_analyze("testing");
        let norm: f32 = vec.iter().map(|x| x * x).sum::<f32>().sqrt();
        assert!(
            (norm - 1.0).abs() < 1e-5,
            "Morphology vector must be normalized"
        );
    }

    #[test]
    fn test_morph_analyze_non_alphanumeric() {
        let vec1 = morph_analyze("test!");
        let vec2 = morph_analyze("test");
        assert_eq!(
            vec1, vec2,
            "Non-alphanumeric trimming should produce identical vectors"
        );
    }

    #[test]
    fn test_root_validation() {
        assert!(is_valid_root("dict"), "Known root 'dict' should validate");
        assert!(is_valid_root("spec"), "Known root 'spec' should validate");
        assert!(!is_valid_root("xyz123"), "Unknown root should not validate");
    }

    #[test]
    fn test_progressive_root_extraction() {
        // This is an implicit test via morph_analyze behavior
        // If we had "dictating" it should find root "dict"
        let _vec = morph_analyze("dictating");
        // The internal logic should strip "ing", leaving "dictat",
        // then progressively strip to find "dict" as a valid root
    }

    #[test]
    fn test_hash_to_float_range() {
        for seed in 0..1000 {
            let val = hash_to_float(seed);
            assert!(
                val >= -0.5 && val < 0.5,
                "hash_to_float must produce values in [-0.5, 0.5)"
            );
        }
    }

    #[test]
    fn test_splitmix64_determinism() {
        let seed = 42;
        let h1 = splitmix64(seed);
        let h2 = splitmix64(seed);
        assert_eq!(h1, h2, "splitmix64 must be deterministic");
    }

    #[test]
    fn test_splitmix64_avalanche() {
        let h1 = splitmix64(0);
        let h2 = splitmix64(1);
        assert_ne!(h1, h2, "splitmix64 must have avalanche properties");
    }
}

File: parts\delimiters.rs
=========================
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use crate::{Delimiter, EncodeOptions, encode};
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn delimiters() {
    println!("Hydron feature required for dynamic delimiters");
}

#[cfg(feature = "hydron")]
pub fn delimiters() {
    // Dynamic Data
    let mut item1 = HashMap::new();
    item1.insert("sku".to_string(), Value::String("A1".to_string()));
    item1.insert("name".to_string(), Value::String("Widget".to_string()));
    item1.insert("qty".to_string(), Value::Integer(2));
    item1.insert("price".to_string(), Value::Float(9.99));

    let mut item2 = HashMap::new();
    item2.insert("sku".to_string(), Value::String("B2".to_string()));
    item2.insert("name".to_string(), Value::String("Gadget".to_string()));
    item2.insert("qty".to_string(), Value::Integer(1));
    item2.insert("price".to_string(), Value::Float(14.5));

    let items_array = Value::Array(vec![Value::Map(item1), Value::Map(item2)]);

    let mut data_map = HashMap::new();
    data_map.insert("items".to_string(), items_array);
    let data = Value::Map(data_map);

    // Tab delimiter (\t)
    let tab = encode(&data, &EncodeOptions::new().with_delimiter(Delimiter::Tab)).unwrap();
    println!("{tab}");

    // Pipe delimiter (|)
    let pipe = encode(&data, &EncodeOptions::new().with_delimiter(Delimiter::Pipe)).unwrap();
    println!("\n{pipe}");
}

File: hydron\values.rs
======================
//! RUNE Evaluation Engine - Runtime Value System
//!
//! Provides runtime evaluation for RUNE expressions, including:
//! - E8 geometric types (vectors, octonions)
//! - GF(8) Galois field arithmetic
//! - Context-aware evaluation based on root declarations
//! - Built-in operations that bridge RUNE into Hydron geometry layers
//!
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, hash_map::Entry};
use std::fmt;
use std::sync::{Arc, Mutex, OnceLock};
use thiserror::Error;

// Hydron geometry layers from hydron-core
use hydron_core::{
    FisherLayer, Gf8, HyperbolicLayer, LorentzianCausalLayer, QuaternionOps, SpacetimePoint,
    SphericalLayer, SymplecticLayer, TopologicalLayer, gf8,
};

// Local SIMD implementations (fallback when feature is disabled)
pub fn gf8_add_simd(a: &[f32; 8], b: &[f32; 8]) -> [f32; 8] {
    // Simple scalar implementation
    let mut result = [0.0f32; 8];
    for i in 0..8 {
        result[i] = a[i] + b[i];
    }
    result
}

pub fn gf8_sub_simd(a: &[f32; 8], b: &[f32; 8]) -> [f32; 8] {
    // Simple scalar implementation
    let mut result = [0.0f32; 8];
    for i in 0..8 {
        result[i] = a[i] - b[i];
    }
    result
}

pub fn gf8_matvec_simd(matrix: &[[f32; 8]; 8], vec: &[f32; 8]) -> [f32; 8] {
    // Matrix-vector multiplication
    let mut result = [0.0f32; 8];
    for i in 0..8 {
        for j in 0..8 {
            result[i] += matrix[i][j] * vec[j];
        }
    }
    result
}

pub fn gf8_norm2_simd(vec: &[f32; 8]) -> f32 {
    // Squared norm
    vec.iter().map(|x| x * x).sum()
}

pub fn gf8_dot_simd(a: &[f32; 8], b: &[f32; 8]) -> f32 {
    // Dot product
    let mut sum = 0.0f32;
    for i in 0..8 {
        sum += a[i] * b[i];
    }
    sum
}

pub fn get_available_f32_256_intrinsics() -> Vec<&'static str> {
    // Return empty vec when SIMD not available
    vec![]
}

pub fn print_simd_capabilities() {
    // No-op when SIMD not available
}

use rune_hex::hex as hex_model;

/// Runtime value types in the E8 ecosystem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Value {
    /// Boolean value
    Bool(bool),

    /// Floating-point number (for RUNE expressions)
    Float(f64),

    /// String value
    String(String),

    /// Array of values
    Array(Vec<Value>),

    /// Scalar numeric value (f32)
    Scalar(f32),

    /// 8-dimensional geometric float (canonical Gf8)
    Gf8(hydron_core::Gf8),

    /// Geo-Semantic lattice frame (allowed E8 root indices)
    Frame(Vec<u8>),

    /// Spatially indexed associative memory (E8 root -> data)
    Atlas(HashMap<u8, Vec<Value>>),

    /// Spacetime point (Lorentzian coords)
    Spacetime(SpacetimePoint),

    /// DomR result (dominant E8 roots)
    DomR(hex_model::DomR),

    /// 8-dimensional vector in E8 lattice
    Vec8([f32; 8]),

    /// 16-dimensional phase space vector (position + momentum)
    Vec16([f32; 16]),

    /// Octonion (8-dimensional non-associative algebra)
    Octonion(Octonion),

    /// Quaternion (4D rotation)
    Quaternion([f32; 4]),

    /// Symbolic reference (unevaluated)
    Symbol(String),

    /// 8x8 matrix (Fisher information, etc.)
    Matrix8x8([[f32; 8]; 8]),

    /// Betti numbers (topological invariants)
    Betti([u32; 3]),

    /// Collection of Vec8 points (for point clouds)
    PointCloud(Vec<[f32; 8]>),

    // --- Extended Types ---
    Integer(i128),
    Byte(u8),
    Char(char),
    Map(HashMap<String, Value>),
    Bytes(Vec<u8>),
    Null,
    Complex([f64; 2]),

    // Advanced Types
    BigInt(Vec<u64>),   // Arbitrary precision integer parts
    Decimal(i128, u32), // Mantissa, Scale (Decimal = m * 10^-s)

    // Structural Types
    Object(RuneObject),
    Enum(String, String, Option<Box<Value>>), // EnumName, Variant, Payload
    Union(Box<Value>),                        // Type-erased union value
    Struct(String, Vec<Value>),               // StructName, Tuple-like fields
    Tuple(Vec<Value>),
    Set(Vec<Value>), // Using Vec for set to allow non-hashable values (linear scan)

    // Functional & Async
    Function(RuneFunction),
    Lambda(RuneLambda),
    #[serde(skip)]
    Future(RuneFuture),
    #[serde(skip)]
    Stream(RuneStream),
    Promise(RunePromise),
    Coroutine(RuneCoroutine),

    // System
    Pointer(usize),
    Interface(String),            // Interface name/ID
    Class(String),                // Class name/ID
    Generic(String, Vec<String>), // Name, TypeParams

    /// Error value
    Error(String),
}

// --- Advanced Type Implementations ---

/// Glyph-capable structural algebra over runtime values.
pub trait RuneGeometric {
    /// Split-join (midpoint / meet) glyph `/\`.
    fn meet(&self, other: &Self) -> Result<Value, EvalError>
    where
        Self: Sized;

    /// Join-split (antipodal midpoint) glyph `\/`.
    fn join(&self, other: &Self) -> Result<Value, EvalError>
    where
        Self: Sized;

    /// Projection glyph `|\`.
    fn project(&self, target: &Self) -> Result<Value, EvalError>
    where
        Self: Sized;

    /// Rejection glyph `\|` (component orthogonal to target).
    fn reject(&self, target: &Self) -> Result<Value, EvalError>
    where
        Self: Sized;

    /// Universal distance glyph `|/` returning a scalar distance.
    fn distance(&self, other: &Self) -> Result<f32, EvalError>
    where
        Self: Sized;

    /// Structural match check for filtering.
    fn matches_pattern(&self, pattern: &Self) -> bool;
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RuneObject {
    pub class: String,
    pub fields: HashMap<String, Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RuneFunction {
    pub name: String,
    pub args: Vec<String>,
    pub body: String, // AST or Bytecode reference
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RuneLambda {
    pub captures: HashMap<String, Value>,
    pub args: Vec<String>,
    pub body: String,
}

#[derive(Debug, Clone)]
pub struct RuneFuture {
    pub id: String,
    pub state: Arc<Mutex<FutureState>>,
}

impl PartialEq for RuneFuture {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Debug, Clone)]
pub enum FutureState {
    Pending,
    Resolved(Value),
    Rejected(String),
}

#[derive(Debug, Clone)]
pub struct RuneStream {
    pub id: String,
    pub buffer: Arc<Mutex<Vec<Value>>>,
}

impl PartialEq for RuneStream {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunePromise {
    pub id: String,
    // Promise is the write-side of a Future
}

impl PartialEq for RunePromise {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuneCoroutine {
    pub id: String,
    pub pc: usize, // Program counter
}

impl PartialEq for RuneCoroutine {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

/// Octonion representation: (scalar, 7 imaginary units)
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct Octonion {
    pub scalar: f32,
    pub i: [f32; 7], // e1, e2, e3, e4, e5, e6, e7
}

impl Octonion {
    /// Create a new octonion
    pub fn new(scalar: f32, i: [f32; 7]) -> Self {
        Self { scalar, i }
    }

    /// Create a real octonion (pure scalar)
    pub fn real(scalar: f32) -> Self {
        Self {
            scalar,
            i: [0.0; 7],
        }
    }

    /// Octonion multiplication (non-associative!)
    ///
    /// Implements full Fano-plane based multiplication:
    /// (a0 + a·e) * (b0 + b·e) =
    ///   (a0*b0 - a·b) + (a0*b + b0*a + a × b),
    /// where a × b is the G₂-invariant 7D cross product induced by the Fano plane.
    pub fn mul(&self, other: &Octonion) -> Octonion {
        let a0 = self.scalar;
        let b0 = other.scalar;
        let a = &self.i;
        let b = &other.i;

        // Scalar part: a0*b0 - a·b
        let mut scalar = a0 * b0;
        for k in 0..7 {
            scalar -= a[k] * b[k];
        }

        // Imaginary part: a0*b + b0*a + a × b
        let mut imag = [0.0f32; 7];

        // Linear terms a0*b + b0*a
        for k in 0..7 {
            imag[k] += a0 * b[k] + b0 * a[k];
        }

        // Cross product term a × b via Fano plane structure constants
        //
        // We encode the oriented Fano triples for the imaginary units e1..e7.
        // Indices 0..6 correspond to e1..e7.
        //
        // The triples below define:
        //   e_i * e_j =  e_k  if (i,j,k) in oriented triple
        //   e_j * e_i = -e_k  (anti-commutativity)
        //
        // The chosen convention is one standard G₂ / octonion orientation:
        //   (1,2,3), (1,4,5), (1,6,7),
        //   (2,4,6), (2,5,7), (3,4,7), (3,5,6)
        const FANO_TRIPLES: &[(usize, usize, usize)] = &[
            (0, 1, 2),
            (0, 3, 4),
            (0, 5, 6),
            (1, 3, 5),
            (1, 4, 6),
            (2, 3, 6),
            (2, 4, 5),
        ];

        // Helper: product of basis elements e_(i+1) * e_(j+1)
        // Returns (scalar_part, imag_basis) where imag_basis[k] is the coefficient of e_(k+1).
        fn basis_mul(i: usize, j: usize) -> (f32, [f32; 7]) {
            debug_assert!(i < 7 && j < 7);
            if i == j {
                // e_i * e_i = -1
                return (-1.0, [0.0; 7]);
            }

            for &(a, b, c) in FANO_TRIPLES.iter() {
                // e_a * e_b =  e_c, e_b * e_a = -e_c
                if i == a && j == b {
                    let mut v = [0.0f32; 7];
                    v[c] = 1.0;
                    return (0.0, v);
                }
                if i == b && j == a {
                    let mut v = [0.0f32; 7];
                    v[c] = -1.0;
                    return (0.0, v);
                }

                // e_b * e_c =  e_a, e_c * e_b = -e_a
                if i == b && j == c {
                    let mut v = [0.0f32; 7];
                    v[a] = 1.0;
                    return (0.0, v);
                }
                if i == c && j == b {
                    let mut v = [0.0f32; 7];
                    v[a] = -1.0;
                    return (0.0, v);
                }

                // e_c * e_a =  e_b, e_a * e_c = -e_b
                if i == c && j == a {
                    let mut v = [0.0f32; 7];
                    v[b] = 1.0;
                    return (0.0, v);
                }
                if i == a && j == c {
                    let mut v = [0.0f32; 7];
                    v[b] = -1.0;
                    return (0.0, v);
                }
            }

            // This should never be reached if FANO_TRIPLES covers all oriented pairs.
            (0.0, [0.0; 7])
        }

        // Accumulate a × b via bilinearity:
        // (∑ a_i e_i) * (∑ b_j e_j) = ∑_{i,j} a_i b_j (e_i * e_j)
        // We already handled the i == j scalar contribution above,
        // so here we only need i != j and only add imaginary parts.
        for i in 0..7 {
            if a[i] == 0.0 {
                continue;
            }
            for j in 0..7 {
                if b[j] == 0.0 || i == j {
                    continue;
                }
                let (_s_part, basis_vec) = basis_mul(i, j);
                let coeff = a[i] * b[j];

                // Only imaginary contributions are expected here (_s_part is 0.0 for i != j).
                for k in 0..7 {
                    imag[k] += coeff * basis_vec[k];
                }
            }
        }

        Octonion { scalar, i: imag }
    }

    /// Conjugate of octonion
    pub fn conjugate(&self) -> Octonion {
        let mut neg_i = self.i;
        for x in &mut neg_i {
            *x = -*x;
        }
        Octonion {
            scalar: self.scalar,
            i: neg_i,
        }
    }

    /// Norm (magnitude) of octonion
    pub fn norm(&self) -> f32 {
        let mut sum = self.scalar * self.scalar;
        for &x in &self.i {
            sum += x * x;
        }
        sum.sqrt()
    }
}

impl fmt::Display for Octonion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.scalar)?;
        for (i, &val) in self.i.iter().enumerate() {
            if val != 0.0 {
                write!(f, " + {}e{}", val, i + 1)?;
            }
        }
        Ok(())
    }
}

// Shared causal layer for Rune runtime (Value payloads)
static CAUSAL_LAYER: OnceLock<Mutex<LorentzianCausalLayer<Value>>> = OnceLock::new();

fn causal_layer() -> &'static Mutex<LorentzianCausalLayer<Value>> {
    CAUSAL_LAYER.get_or_init(|| Mutex::new(LorentzianCausalLayer::new()))
}

// Gf8 is imported from hydron-core via the module re-exports
// (see src/rune/hydron/mod.rs)

impl Value {
    /// Insert data into an Atlas at the location defined by a vector.
    pub fn atlas_insert(&mut self, key_vector: &Value, data: Value) -> Result<(), EvalError> {
        match self {
            Value::Atlas(map) => {
                let gf8 = match key_vector {
                    Value::Gf8(g) => *g,
                    Value::Vec8(v) => hydron_core::Gf8::new(*v),
                    _ => return Err(EvalError::TypeMismatch("Atlas key must be a vector".into())),
                };

                let (idx, _root) = gf8.quantize();

                match map.entry(idx) {
                    Entry::Occupied(mut e) => {
                        e.get_mut().push(data);
                    }
                    Entry::Vacant(e) => {
                        e.insert(vec![data]);
                    }
                }
                Ok(())
            }
            _ => Err(EvalError::TypeMismatch("Target is not an Atlas".into())),
        }
    }

    /// Recall data from an Atlas near the location defined by a vector.
    pub fn atlas_recall(&self, query_vector: &Value) -> Result<Value, EvalError> {
        match self {
            Value::Atlas(map) => {
                let gf8 = match query_vector {
                    Value::Gf8(g) => *g,
                    Value::Vec8(v) => hydron_core::Gf8::new(*v),
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Atlas query must be a vector".into(),
                        ));
                    }
                };

                let (idx, _root) = gf8.quantize();

                if let Some(items) = map.get(&idx) {
                    Ok(Value::Array(items.clone()))
                } else {
                    Ok(Value::Array(vec![]))
                }
            }
            _ => Err(EvalError::TypeMismatch("Target is not an Atlas".into())),
        }
    }
    /// Add two values
    pub fn add(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a + b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Scalar(a + b)),

            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot add arrays of different lengths: {} and {}",
                        a.len(),
                        b.len()
                    )));
                }
                let mut result = Vec::new();
                for (va, vb) in a.iter().zip(b.iter()) {
                    result.push(va.add(vb)?);
                }
                Ok(Value::Array(result))
            }

            (Value::Vec8(a), Value::Vec8(b)) => {
                let mut result = [0.0; 8];
                for i in 0..8 {
                    result[i] = a[i] + b[i];
                }
                Ok(Value::Vec8(result))
            }

            (Value::Gf8(a), Value::Gf8(b)) => {
                #[cfg(feature = "simd")]
                {
                    let result_coords = gf8::gf8_add_simd(a.coords(), b.coords());
                    Ok(Value::Gf8(Gf8::new(result_coords)))
                }
                #[cfg(not(feature = "simd"))]
                {
                    Ok(Value::Gf8(*a + *b))
                }
            }

            (Value::Octonion(a), Value::Octonion(b)) => {
                let mut result_i = [0.0f32; 7];
                for (i, result) in result_i.iter_mut().enumerate() {
                    *result = a.i[i] + b.i[i];
                }
                Ok(Value::Octonion(Octonion {
                    scalar: a.scalar + b.scalar,
                    i: result_i,
                }))
            }

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot add {:?} and {:?}",
                self, other
            ))),
        }
    }

    /// Multiply two values
    pub fn mul(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a * b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Scalar(a * b)),

            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot multiply arrays of different lengths: {} and {}",
                        a.len(),
                        b.len()
                    )));
                }
                let mut result = Vec::new();
                for (va, vb) in a.iter().zip(b.iter()) {
                    result.push(va.mul(vb)?);
                }
                Ok(Value::Array(result))
            }

            (Value::Scalar(s), Value::Vec8(v)) | (Value::Vec8(v), Value::Scalar(s)) => {
                let mut result = [0.0; 8];
                for i in 0..8 {
                    result[i] = v[i] * s;
                }
                Ok(Value::Vec8(result))
            }

            (Value::Gf8(a), Value::Scalar(s)) | (Value::Scalar(s), Value::Gf8(a)) => {
                Ok(Value::Gf8(*a * *s))
            }

            (Value::Octonion(a), Value::Octonion(b)) => Ok(Value::Octonion(a.mul(b))),

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot multiply {:?} and {:?}",
                self, other
            ))),
        }
    }

    /// Subtract two values
    pub fn sub(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a - b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Scalar(a - b)),

            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot subtract arrays of different lengths: {} and {}",
                        a.len(),
                        b.len()
                    )));
                }
                let mut result = Vec::new();
                for (va, vb) in a.iter().zip(b.iter()) {
                    result.push(va.sub(vb)?);
                }
                Ok(Value::Array(result))
            }

            (Value::Vec8(a), Value::Vec8(b)) => {
                let mut result = [0.0; 8];
                for i in 0..8 {
                    result[i] = a[i] - b[i];
                }
                Ok(Value::Vec8(result))
            }

            (Value::Gf8(a), Value::Gf8(b)) => Ok(Value::Gf8(*a - *b)),

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot subtract {:?} and {:?}",
                self, other
            ))),
        }
    }

    /// Divide two values
    pub fn div(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => {
                if *b == 0.0 {
                    return Err(EvalError::DivisionByZero);
                }
                Ok(Value::Float(a / b))
            }

            (Value::Scalar(a), Value::Scalar(b)) => {
                if *b == 0.0 {
                    return Err(EvalError::DivisionByZero);
                }
                Ok(Value::Scalar(a / b))
            }

            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot divide arrays of different lengths: {} and {}",
                        a.len(),
                        b.len()
                    )));
                }
                let mut result = Vec::new();
                for (va, vb) in a.iter().zip(b.iter()) {
                    result.push(va.div(vb)?);
                }
                Ok(Value::Array(result))
            }

            (Value::Vec8(v), Value::Scalar(s)) => {
                if *s == 0.0 {
                    return Err(EvalError::DivisionByZero);
                }
                let mut result = [0.0; 8];
                for i in 0..8 {
                    result[i] = v[i] / s;
                }
                Ok(Value::Vec8(result))
            }

            (Value::Gf8(_a), Value::Gf8(_b)) => {
                // Division for geometric Gf8 not directly supported
                Err(EvalError::TypeMismatch(
                    "Division not supported for Gf8 geometric types".to_string(),
                ))
            }

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot divide {:?} by {:?}",
                self, other
            ))),
        }
    }

    /// Power operation
    pub fn pow(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.powf(*b))),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Scalar(a.powf(*b))),

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot raise {:?} to power {:?}",
                self, other
            ))),
        }
    }

    /// Modulo operation
    pub fn modulo(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => {
                if *b == 0.0 {
                    return Err(EvalError::DivisionByZero);
                }
                Ok(Value::Float(a % b))
            }

            (Value::Scalar(a), Value::Scalar(b)) => {
                if *b == 0.0 {
                    return Err(EvalError::DivisionByZero);
                }
                Ok(Value::Scalar(a % b))
            }

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot compute {:?} mod {:?}",
                self, other
            ))),
        }
    }

    /// Geometric midpoint (type-preserving where possible).
    /// Used by the `/\` and `/|` glyphs.
    pub fn geometric_midpoint(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            // Preserve Gf8 on the spherical manifold via SLERP at t = 0.5
            (Value::Gf8(a), Value::Gf8(b)) => Ok(Value::Gf8(a.spherical_slerp(b, 0.5))),

            // Quaternion midpoint via SLERP
            (Value::Quaternion(a), Value::Quaternion(b)) => {
                Ok(Value::Quaternion(QuaternionOps::slerp(a, b, 0.5)))
            }

            // Octonion linear average (vector space)
            (Value::Octonion(a), Value::Octonion(b)) => {
                let scalar = (a.scalar + b.scalar) * 0.5;
                let mut i = [0.0; 7];
                for k in 0..7 {
                    i[k] = (a.i[k] + b.i[k]) * 0.5;
                }
                Ok(Value::Octonion(Octonion { scalar, i }))
            }

            // Vec8 midpoint
            (Value::Vec8(a), Value::Vec8(b)) => {
                let mut res = [0.0; 8];
                for k in 0..8 {
                    res[k] = (a[k] + b[k]) * 0.5;
                }
                Ok(Value::Vec8(res))
            }

            // Vec16 midpoint
            (Value::Vec16(a), Value::Vec16(b)) => {
                let mut res = [0.0; 16];
                for k in 0..16 {
                    res[k] = (a[k] + b[k]) * 0.5;
                }
                Ok(Value::Vec16(res))
            }

            // Scalar/float midpoint returned as Scalar (geometry is f32-based)
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Scalar((a + b) * 0.5)),
            (Value::Float(a), Value::Float(b)) => Ok(Value::Scalar((*a as f32 + *b as f32) * 0.5)),
            (Value::Scalar(a), Value::Float(b)) | (Value::Float(b), Value::Scalar(a)) => {
                Ok(Value::Scalar((*a + *b as f32) * 0.5))
            }

            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot compute midpoint of {:?} and {:?}",
                self, other
            ))),
        }
    }

    /// Antipodal midpoint (mean then negate). Used by `\/`.
    pub fn geometric_antipode_midpoint(&self, other: &Value) -> Result<Value, EvalError> {
        let mid = self.geometric_midpoint(other)?;
        mid.negate()
    }

    /// Project `self` onto `target` (|\ glyph).
    pub fn geometric_project(&self, target: &Value) -> Result<Value, EvalError> {
        match (self, target) {
            (Value::Gf8(v), Value::Gf8(u)) => {
                let dot = v.dot(u.coords());
                let base = *u.coords();
                Ok(Value::Vec8(base.map(|x| x * dot)))
            }
            (Value::Vec8(v), Value::Vec8(u)) => {
                let dot: f32 = v.iter().zip(u.iter()).map(|(a, b)| a * b).sum();
                let norm_sq: f32 = u.iter().map(|a| a * a).sum();
                if norm_sq < 1e-9 {
                    return Ok(Value::Vec8([0.0; 8]));
                }
                let scale = dot / norm_sq;
                Ok(Value::Vec8((*u).map(|x| x * scale)))
            }

            (Value::Vec16(v), Value::Vec16(u)) => {
                let dot: f32 = v.iter().zip(u.iter()).map(|(a, b)| a * b).sum();
                let norm_sq: f32 = u.iter().map(|a| a * a).sum();
                if norm_sq < 1e-9 {
                    return Ok(Value::Vec16([0.0; 16]));
                }
                let scale = dot / norm_sq;
                Ok(Value::Vec16(u.map(|x| x * scale)))
            }
            _ => Err(EvalError::TypeMismatch(format!(
                "Projection requires compatible vector types: {:?} -> {:?}",
                self, target
            ))),
        }
    }

    /// Reject `self` from `target` (component orthogonal to target). Used by `\|`.
    pub fn geometric_reject(&self, target: &Value) -> Result<Value, EvalError> {
        match (self, target) {
            (Value::Gf8(v), Value::Gf8(u)) => {
                let v_coords = *v.coords();
                let u_coords = *u.coords();
                let dot = v.dot(u.coords());
                let norm_sq: f32 = u_coords.iter().map(|x| x * x).sum();
                if norm_sq < 1e-9 {
                    return Ok(Value::Vec8(v_coords));
                }
                let scale = dot / norm_sq;
                let mut rej = [0.0f32; 8];
                for i in 0..8 {
                    rej[i] = v_coords[i] - u_coords[i] * scale;
                }
                Ok(Value::Vec8(rej))
            }
            (Value::Vec8(v), Value::Vec8(u)) => {
                let dot: f32 = v.iter().zip(u.iter()).map(|(a, b)| a * b).sum();
                let norm_sq: f32 = u.iter().map(|a| a * a).sum();
                if norm_sq < 1e-9 {
                    return Ok(Value::Vec8(*v));
                }
                let scale = dot / norm_sq;
                let mut rej = [0.0f32; 8];
                for i in 0..8 {
                    rej[i] = v[i] - u[i] * scale;
                }
                Ok(Value::Vec8(rej))
            }

            (Value::Vec16(v), Value::Vec16(u)) => {
                let dot: f32 = v.iter().zip(u.iter()).map(|(a, b)| a * b).sum();
                let norm_sq: f32 = u.iter().map(|a| a * a).sum();
                if norm_sq < 1e-9 {
                    return Ok(Value::Vec16(*v));
                }
                let scale = dot / norm_sq;
                let mut rej = [0.0f32; 16];
                for i in 0..16 {
                    rej[i] = v[i] - u[i] * scale;
                }
                Ok(Value::Vec16(rej))
            }
            _ => Err(EvalError::TypeMismatch(format!(
                "Rejection requires compatible vector types: {:?} ⟂ {:?}",
                self, target
            ))),
        }
    }

    /// Geometric distance (context-aware where possible). Used by `|/`.
    pub fn geometric_distance(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            // Spherical distance for Gf8
            (Value::Gf8(a), Value::Gf8(b)) => Ok(Value::Scalar(a.spherical_distance_to(b))),

            // Euclidean distance for Vec8
            (Value::Vec8(a), Value::Vec8(b)) => {
                let mut sum = 0.0f32;
                for i in 0..8 {
                    let d = a[i] - b[i];
                    sum += d * d;
                }
                Ok(Value::Scalar(sum.sqrt()))
            }

            // Euclidean distance for Vec16
            (Value::Vec16(a), Value::Vec16(b)) => {
                let mut sum = 0.0f32;
                for i in 0..16 {
                    let d = a[i] - b[i];
                    sum += d * d;
                }
                Ok(Value::Scalar(sum.sqrt()))
            }

            // Scalar distance (absolute difference)
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Scalar((a - b).abs())),
            (Value::Float(a), Value::Float(b)) => Ok(Value::Scalar((*a as f32 - *b as f32).abs())),
            (Value::Scalar(a), Value::Float(b)) | (Value::Float(b), Value::Scalar(a)) => {
                Ok(Value::Scalar((*a - *b as f32).abs()))
            }

            _ => Err(EvalError::TypeMismatch(format!(
                "Distance requires compatible geometric types: {:?} and {:?}",
                self, other
            ))),
        }
    }

    /// Negate a value (unary minus)
    pub fn negate(&self) -> Result<Value, EvalError> {
        match self {
            Value::Float(a) => Ok(Value::Float(-a)),
            Value::Scalar(a) => Ok(Value::Scalar(-a)),

            Value::Array(a) => {
                let mut result = Vec::new();
                for val in a.iter() {
                    result.push(val.negate()?);
                }
                Ok(Value::Array(result))
            }

            Value::Vec8(v) => {
                let mut result = [0.0; 8];
                for i in 0..8 {
                    result[i] = -v[i];
                }
                Ok(Value::Vec8(result))
            }

            Value::Vec16(v) => {
                let mut result = [0.0; 16];
                for i in 0..16 {
                    result[i] = -v[i];
                }
                Ok(Value::Vec16(result))
            }

            Value::Quaternion(q) => Ok(Value::Quaternion([-q[0], -q[1], -q[2], -q[3]])),

            Value::Gf8(g) => Ok(Value::Gf8(-*g)),

            Value::Octonion(o) => Ok(Value::Octonion(Octonion {
                scalar: -o.scalar,
                i: o.i.map(|x| -x),
            })),

            Value::Map(m) => {
                let mut out = HashMap::with_capacity(m.len());
                for (k, v) in m {
                    out.insert(k.clone(), v.negate()?);
                }
                Ok(Value::Map(out))
            }

            Value::Object(obj) => {
                let mut fields = HashMap::with_capacity(obj.fields.len());
                for (k, v) in &obj.fields {
                    fields.insert(k.clone(), v.negate()?);
                }
                Ok(Value::Object(RuneObject {
                    class: obj.class.clone(),
                    fields,
                }))
            }

            Value::Tuple(vals) => {
                let mut out = Vec::with_capacity(vals.len());
                for v in vals {
                    out.push(v.negate()?);
                }
                Ok(Value::Tuple(out))
            }

            Value::Struct(name, vals) => {
                let mut out = Vec::with_capacity(vals.len());
                for v in vals {
                    out.push(v.negate()?);
                }
                Ok(Value::Struct(name.clone(), out))
            }

            _ => Err(EvalError::TypeMismatch(format!("Cannot negate {:?}", self))),
        }
    }

    /// Less than comparison
    pub fn lt(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a < b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Bool(a < b)),
            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot compare {:?} < {:?}",
                self, other
            ))),
        }
    }

    /// Less than or equal comparison
    pub fn le(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a <= b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Bool(a <= b)),
            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot compare {:?} <= {:?}",
                self, other
            ))),
        }
    }

    /// Greater than comparison
    pub fn gt(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a > b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Bool(a > b)),
            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot compare {:?} > {:?}",
                self, other
            ))),
        }
    }

    /// Greater than or equal comparison
    pub fn ge(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a >= b)),
            (Value::Scalar(a), Value::Scalar(b)) => Ok(Value::Bool(a >= b)),
            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot compare {:?} >= {:?}",
                self, other
            ))),
        }
    }

    /// Logical AND
    pub fn and(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Bool(a), Value::Bool(b)) => Ok(Value::Bool(*a && *b)),
            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot apply AND to {:?} and {:?}",
                self, other
            ))),
        }
    }

    /// Logical OR
    pub fn or(&self, other: &Value) -> Result<Value, EvalError> {
        match (self, other) {
            (Value::Bool(a), Value::Bool(b)) => Ok(Value::Bool(*a || *b)),
            _ => Err(EvalError::TypeMismatch(format!(
                "Cannot apply OR to {:?} and {:?}",
                self, other
            ))),
        }
    }
}

impl RuneGeometric for Value {
    /// Structural containment check: returns true if `self` matches the pattern structurally.
    /// Arrays: all elements must match any element in pattern array? Here we require same length and per-index match.
    /// Maps/Objects: pattern keys must exist in self with matching substructure.
    fn matches_pattern(&self, pattern: &Value) -> bool {
        match (self, pattern) {
            (Value::Map(m), Value::Map(p)) => {
                for (k, pv) in p {
                    if let Some(v) = m.get(k) {
                        if !v.matches_pattern(pv) {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                true
            }
            (Value::Object(o), Value::Object(p)) => {
                if o.class != p.class {
                    return false;
                }
                for (k, pv) in &p.fields {
                    if let Some(v) = o.fields.get(k) {
                        if !v.matches_pattern(pv) {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                true
            }
            (Value::Struct(name_a, a), Value::Struct(name_b, b)) => {
                if name_a != name_b || a.len() != b.len() {
                    return false;
                }
                a.iter()
                    .zip(b.iter())
                    .all(|(va, vb)| va.matches_pattern(vb))
            }
            (Value::Tuple(a), Value::Tuple(b)) => {
                if a.len() != b.len() {
                    return false;
                }
                a.iter()
                    .zip(b.iter())
                    .all(|(va, vb)| va.matches_pattern(vb))
            }
            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return false;
                }
                a.iter()
                    .zip(b.iter())
                    .all(|(va, vb)| va.matches_pattern(vb))
            }
            // Primitive equality fallback
            _ => self == pattern,
        }
    }
    fn meet(&self, other: &Self) -> Result<Value, EvalError> {
        match (self, other) {
            // Structural recursion
            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Array length mismatch in structural glyph".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.meet(vb)?);
                }
                Ok(Value::Array(out))
            }

            (Value::Tuple(a), Value::Tuple(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Tuple length mismatch in structural glyph".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.meet(vb)?);
                }
                Ok(Value::Tuple(out))
            }

            (Value::Struct(name_a, a), Value::Struct(name_b, b)) => {
                if name_a != name_b {
                    return Err(EvalError::TypeMismatch(format!(
                        "Struct name mismatch: {} vs {}",
                        name_a, name_b
                    )));
                }
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Struct field arity mismatch in structural glyph".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.meet(vb)?);
                }
                Ok(Value::Struct(name_a.clone(), out))
            }

            (Value::Map(a), Value::Map(b)) => {
                let mut out = HashMap::new();
                for (k, va) in a {
                    if let Some(vb) = b.get(k) {
                        out.insert(k.clone(), va.meet(vb)?);
                    }
                }
                Ok(Value::Map(out))
            }

            (Value::Object(a), Value::Object(b)) => {
                if a.class != b.class {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot merge different classes: {} and {}",
                        a.class, b.class
                    )));
                }
                let mut fields = HashMap::new();
                for (k, va) in &a.fields {
                    if let Some(vb) = b.fields.get(k) {
                        fields.insert(k.clone(), va.meet(vb)?);
                    }
                }
                Ok(Value::Object(RuneObject {
                    class: a.class.clone(),
                    fields,
                }))
            }

            // Leaf path
            _ => self.geometric_midpoint(other),
        }
    }

    fn join(&self, other: &Self) -> Result<Value, EvalError> {
        let mid = self.meet(other)?;
        mid.negate()
    }

    fn project(&self, target: &Self) -> Result<Value, EvalError> {
        match (self, target) {
            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Array length mismatch in projection".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.project(vb)?);
                }
                Ok(Value::Array(out))
            }

            (Value::Tuple(a), Value::Tuple(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Tuple length mismatch in projection".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.project(vb)?);
                }
                Ok(Value::Tuple(out))
            }

            (Value::Struct(name_a, a), Value::Struct(name_b, b)) => {
                if name_a != name_b {
                    return Err(EvalError::TypeMismatch(format!(
                        "Struct name mismatch: {} vs {}",
                        name_a, name_b
                    )));
                }
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Struct field arity mismatch in projection".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.project(vb)?);
                }
                Ok(Value::Struct(name_a.clone(), out))
            }

            (Value::Map(a), Value::Map(b)) => {
                let mut out = HashMap::new();
                for (k, va) in a {
                    if let Some(vb) = b.get(k) {
                        out.insert(k.clone(), va.project(vb)?);
                    }
                }
                Ok(Value::Map(out))
            }

            (Value::Object(a), Value::Object(b)) => {
                if a.class != b.class {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot project different classes: {} and {}",
                        a.class, b.class
                    )));
                }
                let mut fields = HashMap::new();
                for (k, va) in &a.fields {
                    if let Some(vb) = b.fields.get(k) {
                        fields.insert(k.clone(), va.project(vb)?);
                    }
                }
                Ok(Value::Object(RuneObject {
                    class: a.class.clone(),
                    fields,
                }))
            }

            _ => self.geometric_project(target),
        }
    }

    fn reject(&self, target: &Self) -> Result<Value, EvalError> {
        match (self, target) {
            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Array length mismatch in rejection".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.reject(vb)?);
                }
                Ok(Value::Array(out))
            }

            (Value::Tuple(a), Value::Tuple(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Tuple length mismatch in rejection".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.reject(vb)?);
                }
                Ok(Value::Tuple(out))
            }

            (Value::Struct(name_a, a), Value::Struct(name_b, b)) => {
                if name_a != name_b {
                    return Err(EvalError::TypeMismatch(format!(
                        "Struct name mismatch: {} vs {}",
                        name_a, name_b
                    )));
                }
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Struct field arity mismatch in rejection".into(),
                    ));
                }
                let mut out = Vec::with_capacity(a.len());
                for (va, vb) in a.iter().zip(b.iter()) {
                    out.push(va.reject(vb)?);
                }
                Ok(Value::Struct(name_a.clone(), out))
            }

            (Value::Map(a), Value::Map(b)) => {
                let mut out = HashMap::new();
                for (k, va) in a {
                    if let Some(vb) = b.get(k) {
                        out.insert(k.clone(), va.reject(vb)?);
                    }
                }
                Ok(Value::Map(out))
            }

            (Value::Object(a), Value::Object(b)) => {
                if a.class != b.class {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot reject across different classes: {} and {}",
                        a.class, b.class
                    )));
                }
                let mut fields = HashMap::new();
                for (k, va) in &a.fields {
                    if let Some(vb) = b.fields.get(k) {
                        fields.insert(k.clone(), va.reject(vb)?);
                    }
                }
                Ok(Value::Object(RuneObject {
                    class: a.class.clone(),
                    fields,
                }))
            }

            _ => self.geometric_reject(target),
        }
    }

    fn distance(&self, other: &Self) -> Result<f32, EvalError> {
        match (self, other) {
            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Array length mismatch in distance".into(),
                    ));
                }
                let mut accum = 0.0f32;
                for (va, vb) in a.iter().zip(b.iter()) {
                    accum += va.distance(vb)?;
                }
                let n = a.len() as f32;
                Ok(if n > 0.0 { accum / n } else { 0.0 })
            }

            (Value::Tuple(a), Value::Tuple(b)) => {
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Tuple length mismatch in distance".into(),
                    ));
                }
                let mut accum = 0.0f32;
                for (va, vb) in a.iter().zip(b.iter()) {
                    accum += va.distance(vb)?;
                }
                let n = a.len() as f32;
                Ok(if n > 0.0 { accum / n } else { 0.0 })
            }

            (Value::Struct(name_a, a), Value::Struct(name_b, b)) => {
                if name_a != name_b {
                    return Err(EvalError::TypeMismatch(format!(
                        "Struct name mismatch: {} vs {}",
                        name_a, name_b
                    )));
                }
                if a.len() != b.len() {
                    return Err(EvalError::TypeMismatch(
                        "Struct field arity mismatch in distance".into(),
                    ));
                }
                let mut accum = 0.0f32;
                for (va, vb) in a.iter().zip(b.iter()) {
                    accum += va.distance(vb)?;
                }
                let n = a.len() as f32;
                Ok(if n > 0.0 { accum / n } else { 0.0 })
            }

            (Value::Map(a), Value::Map(b)) => {
                let mut accum = 0.0f32;
                let mut count = 0usize;
                for (k, va) in a {
                    if let Some(vb) = b.get(k) {
                        accum += va.distance(vb)?;
                        count += 1;
                    }
                }
                Ok(if count > 0 { accum / count as f32 } else { 0.0 })
            }

            (Value::Object(a), Value::Object(b)) => {
                if a.class != b.class {
                    return Err(EvalError::TypeMismatch(format!(
                        "Cannot measure distance across different classes: {} and {}",
                        a.class, b.class
                    )));
                }
                let mut accum = 0.0f32;
                let mut count = 0usize;
                for (k, va) in &a.fields {
                    if let Some(vb) = b.fields.get(k) {
                        accum += va.distance(vb)?;
                        count += 1;
                    }
                }
                Ok(if count > 0 { accum / count as f32 } else { 0.0 })
            }

            _ => match self.geometric_distance(other)? {
                Value::Scalar(s) => Ok(s),
                Value::Float(f) => Ok(f as f32),
                other => Err(EvalError::TypeMismatch(format!(
                    "Distance expected scalar, got {:?}",
                    other
                ))),
            },
        }
    }
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Bool(b) => write!(f, "{}", b),
            Value::Float(v) => write!(f, "{}", v),
            Value::String(s) => write!(f, "{}", s),
            Value::Array(arr) => {
                write!(f, "[")?;
                for (i, val) in arr.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    write!(f, "{}", val)?;
                }
                write!(f, "]")
            }
            Value::Scalar(v) => write!(f, "{}", v),
            Value::Gf8(g) => write!(f, "Gf8({})", g.to_scalar()),
            Value::Vec8(v) => write!(
                f,
                "Vec8[{}, {}, {}, {}, {}, {}, {}, {}]",
                v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]
            ),
            Value::Vec16(v) => write!(
                f,
                "Vec16[{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}]",
                v[0],
                v[1],
                v[2],
                v[3],
                v[4],
                v[5],
                v[6],
                v[7],
                v[8],
                v[9],
                v[10],
                v[11],
                v[12],
                v[13],
                v[14],
                v[15]
            ),
            Value::Octonion(o) => write!(f, "{}", o),
            Value::Quaternion(q) => write!(f, "Quat[{}, {}, {}, {}]", q[0], q[1], q[2], q[3]),
            Value::Spacetime(p) => write!(
                f,
                "Spacetime[t={}, x1={}, x2={}, x3={}, x4={}, x5={}, x6={}, x7={}]",
                p.coords[0],
                p.coords[1],
                p.coords[2],
                p.coords[3],
                p.coords[4],
                p.coords[5],
                p.coords[6],
                p.coords[7]
            ),
            Value::DomR(d) => write!(
                f,
                "DomR(roots={}, scores={})",
                d.roots.len(),
                d.scores.len()
            ),
            Value::Frame(indices) => write!(f, "Frame({} indices)", indices.len()),
            Value::Atlas(map) => write!(f, "Atlas({} roots)", map.len()),
            Value::Symbol(s) => write!(f, "{}", s),
            Value::Matrix8x8(_) => write!(f, "Matrix8x8[...]"),
            Value::Betti(b) => write!(f, "Betti[{}, {}, {}]", b[0], b[1], b[2]),
            Value::PointCloud(points) => write!(f, "PointCloud[{} points]", points.len()),

            // Extended Types Display
            Value::Integer(i) => write!(f, "{}", i),
            Value::Byte(b) => write!(f, "0x{:02X}", b),
            Value::Char(c) => write!(f, "'{}'", c),
            Value::Map(m) => {
                write!(f, "{{")?;
                for (i, (k, v)) in m.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    write!(f, "{}: {}", k, v)?;
                }
                write!(f, "}}")
            }
            Value::Bytes(b) => write!(f, "Bytes[{}]", b.len()),
            Value::Null => write!(f, "null"),
            Value::Complex(c) => write!(f, "{} + {}i", c[0], c[1]),

            // Advanced Types
            Value::BigInt(parts) => write!(f, "BigInt({:?})", parts),
            Value::Decimal(m, s) => write!(f, "Decimal({}e-{})", m, s),

            // Structural
            Value::Object(obj) => write!(f, "Object({})", obj.class),
            Value::Enum(name, variant, _) => write!(f, "{}::{}", name, variant),
            Value::Union(val) => write!(f, "Union({})", val),
            Value::Struct(name, _) => write!(f, "Struct({})", name),
            Value::Tuple(vals) => write!(f, "Tuple({})", vals.len()),
            Value::Set(vals) => write!(f, "Set({})", vals.len()),

            // Functional & Async
            Value::Function(func) => write!(f, "Fn({})", func.name),
            Value::Lambda(_) => write!(f, "Lambda"),
            Value::Future(fut) => write!(f, "Future({})", fut.id),
            Value::Stream(s) => write!(f, "Stream({})", s.id),
            Value::Promise(p) => write!(f, "Promise({})", p.id),
            Value::Coroutine(c) => write!(f, "Coroutine({})", c.id),

            // System
            Value::Pointer(p) => write!(f, "Ptr(0x{:x})", p),
            Value::Interface(i) => write!(f, "Interface({})", i),
            Value::Class(c) => write!(f, "Class({})", c),
            Value::Generic(n, _) => write!(f, "Generic({})", n),

            Value::Error(e) => write!(f, "Error: {}", e),
        }
    }
}

/// Evaluation context with variable bindings and root context
#[derive(Debug, Clone)]
pub struct EvalContext {
    /// Variable bindings
    pub variables: HashMap<String, Value>,

    /// Semantic variable bindings (prefix:name -> value)
    pub semantic_vars: HashMap<String, Value>,

    /// Current root context (affects interpretation)
    root: Option<String>,
}

impl EvalContext {
    /// Create a new evaluation context
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            semantic_vars: HashMap::new(),
            root: None,
        }
    }

    /// Set the root context
    pub fn set_root(&mut self, root: String) {
        self.root = Some(root);
    }

    /// Get the current root context
    pub fn root(&self) -> Option<&str> {
        self.root.as_deref()
    }

    /// Bind a variable to a value
    pub fn bind(&mut self, name: String, value: Value) {
        self.variables.insert(name, value);
    }

    /// Look up a variable
    pub fn lookup(&self, name: &str) -> Option<&Value> {
        self.variables.get(name)
    }
}

impl Default for EvalContext {
    fn default() -> Self {
        Self::new()
    }
}

/// Evaluation errors
#[derive(Debug, Error)]
pub enum EvalError {
    #[error("Type mismatch: {0}")]
    TypeMismatch(String),

    #[error("Undefined variable: {0}")]
    UndefinedVariable(String),

    #[error("Division by zero")]
    DivisionByZero,

    #[error("Invalid operation: {0}")]
    InvalidOperation(String),

    #[error("Unsupported operation: {0}")]
    UnsupportedOperation(String),

    #[error("Not implemented: {0}")]
    NotImplemented(String),
}

// ===================================
// From trait implementations - automatic Value wrapping
// ===================================

impl From<[f32; 8]> for Value {
    fn from(arr: [f32; 8]) -> Self {
        Value::Vec8(arr)
    }
}

impl From<[f32; 16]> for Value {
    fn from(arr: [f32; 16]) -> Self {
        Value::Vec16(arr)
    }
}

impl From<[f32; 4]> for Value {
    fn from(arr: [f32; 4]) -> Self {
        Value::Quaternion(arr)
    }
}

impl From<[u32; 3]> for Value {
    fn from(arr: [u32; 3]) -> Self {
        Value::Betti(arr)
    }
}

// ===================================
// RuneBuiltin - Geometric Operation Dispatch
// ===================================

/// Built-in geometric operations that bridge RUNE into Hydron
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RuneBuiltin {
    // Gf8 core operations
    Gf8Norm,      // [f32;8] → f32
    Gf8Normalize, // [f32;8] → [f32;8]
    Gf8Dot,       // [f32;8], [f32;8] → f32

    // Spherical (S7) operations
    S7Project,   // [f32;8] → [f32;8]
    S7Distance,  // [f32;8], [f32;8] → f32
    S7Slerp,     // [f32;8], [f32;8], f32 → [f32;8]
    S7Antipodal, // [f32;8] → [f32;8]
    S7Mean,      // [[f32;8]] → [f32;8]

    // Hyperbolic operations
    H8Distance,  // [f32;8], [f32;8] → f32
    H8MobiusAdd, // [f32;8], [f32;8] → [f32;8]

    // Fisher information geometry
    FisherDistance, // [f32;8], [f32;8] → f32
    FisherMatrix,   // [f32;8] → [[f32;8];8]
    KLDivergence,   // [f32;8], [f32;8] → f32
    FisherFilter,   // Array, threshold -> Array (novelty filter)

    // Quaternion operations
    QuatSlerp,     // [f32;4], [f32;4], f32 → [f32;4]
    QuatCompose,   // [f32;4], [f32;4] → [f32;4]
    QuatConjugate, // [f32;4] → [f32;4]

    // Symplectic operations
    SymHamiltonian, // [f32;16] → f32
    SymEvolveStep,  // [f32;16], f32 → [f32;16]

    // Lorentzian spacetime operations
    LorentzianCausal,   // [f32;8], [f32;8] → bool
    LorentzianDistance, // [f32;8], [f32;8] → f32
    CausalNow,          // () -> [f32;8]
    CausalEmit,         // any, optional root, optional causes -> event_id
    CausalLink,         // cause_id, effect_id -> ()
    CausalConePast,     // id -> [ids]
    CausalConeFuture,   // id -> [ids]
    CausalVerify,       // () -> bool
    Fold,               // [values], op -> value
    Filter,             // [values], pattern -> [values]
    AtlasNew,           // -> Atlas
    AtlasInsert,        // [Atlas, KeyVec, Data] -> Atlas
    AtlasRecall,        // [Atlas, QueryVec] -> Array
    Neighbors,          // Integer -> Array<Integer>
    Reflect,            // [Vec8, Vec8] -> Vec8 (Weyl reflection)
    Diffuse,            // [Array<f32;240], Scalar] -> Array<f32;240>

    // Topological operations
    TopoBetti,     // [[f32;8]] → [u32;3]
    TopoSignature, // [[f32;8]] → symbol

    // CUDA orchestration
    CudaVecDot,        // GPU row-wise dot
    CudaTopK,          // GPU top-k
    CudaDomR,          // GPU DomR (E8-native dominant roots)
    CudaArchetypeDomR, // Archetype dispatch for DomR

    // E8 graph/ontology helpers
    E8TypeI,      // Axes[] -> Vec<Vec8> (Type-I roots)
    E8TypeII,     // Axes[] -> Vec<Vec8> (Type-II spinors)
    E8EdgesWhere, // Vertices[] -> Edges[] (inner product rule)
    HexGraph,     // (vertices, edges, axes) -> Map graph

    // Perception operations
    Perceive, // String → Vec8 (Signal /\ Structure)
}

impl RuneBuiltin {
    /// Create a RuneBuiltin from a name string (case-insensitive).
    pub fn from_str(name: &str) -> Option<Self> {
        match name.to_lowercase().as_str() {
            // Perception operations
            "perceive" => Some(RuneBuiltin::Perceive),

            // E8 graph helpers
            "e8typei" => Some(RuneBuiltin::E8TypeI),
            "e8typeii" => Some(RuneBuiltin::E8TypeII),
            "e8edgeswhere" => Some(RuneBuiltin::E8EdgesWhere),
            "e8edges" => Some(RuneBuiltin::E8EdgesWhere),
            "HexGraph" => Some(RuneBuiltin::HexGraph),
            "t:HexGraph" => Some(RuneBuiltin::HexGraph),

            // Gf8 operations
            "gf8norm" => Some(RuneBuiltin::Gf8Norm),
            "gf8normalize" => Some(RuneBuiltin::Gf8Normalize),
            "gf8dot" => Some(RuneBuiltin::Gf8Dot),

            // Spherical operations
            "s7project" => Some(RuneBuiltin::S7Project),
            "s7distance" => Some(RuneBuiltin::S7Distance),
            "s7slerp" => Some(RuneBuiltin::S7Slerp),
            "s7antipodal" => Some(RuneBuiltin::S7Antipodal),
            "s7mean" => Some(RuneBuiltin::S7Mean),

            // Hyperbolic operations
            "h8distance" => Some(RuneBuiltin::H8Distance),
            "h8mobiusadd" => Some(RuneBuiltin::H8MobiusAdd),

            // Fisher geometry
            "fisherdistance" => Some(RuneBuiltin::FisherDistance),
            "fishermatrix" => Some(RuneBuiltin::FisherMatrix),
            "kldivergence" => Some(RuneBuiltin::KLDivergence),
            "fisherfilter" => Some(RuneBuiltin::FisherFilter),

            // Quaternion operations
            "quatslerp" => Some(RuneBuiltin::QuatSlerp),
            "quatcompose" => Some(RuneBuiltin::QuatCompose),
            "quatconjugate" => Some(RuneBuiltin::QuatConjugate),

            // Symplectic operations
            "symhamiltonian" => Some(RuneBuiltin::SymHamiltonian),
            "symevolvestep" => Some(RuneBuiltin::SymEvolveStep),

            // Lorentzian operations
            "lorentziancausal" => Some(RuneBuiltin::LorentzianCausal),
            "lorentziandistance" => Some(RuneBuiltin::LorentzianDistance),
            "causalnow" => Some(RuneBuiltin::CausalNow),
            "causalemit" => Some(RuneBuiltin::CausalEmit),
            "causallink" => Some(RuneBuiltin::CausalLink),
            "causalconepast" => Some(RuneBuiltin::CausalConePast),
            "causalconefuture" => Some(RuneBuiltin::CausalConeFuture),
            "causalverify" => Some(RuneBuiltin::CausalVerify),
            "fold" => Some(RuneBuiltin::Fold),
            "filter" => Some(RuneBuiltin::Filter),
            "atlasnew" => Some(RuneBuiltin::AtlasNew),
            "atlasinsert" => Some(RuneBuiltin::AtlasInsert),
            "atlasrecall" => Some(RuneBuiltin::AtlasRecall),
            "neighbors" => Some(RuneBuiltin::Neighbors),
            "reflect" => Some(RuneBuiltin::Reflect),
            "diffuse" => Some(RuneBuiltin::Diffuse),

            // Topological operations
            "topobetti" => Some(RuneBuiltin::TopoBetti),
            "toposignature" => Some(RuneBuiltin::TopoSignature),

            // CUDA builtins (feature-gated at execution)
            "cuda:vecdot" => Some(RuneBuiltin::CudaVecDot),
            "cuda:topk" => Some(RuneBuiltin::CudaTopK),
            "cuda:domr" => Some(RuneBuiltin::CudaDomR),
            "cuda:archetype:domr" => Some(RuneBuiltin::CudaArchetypeDomR),
            _ => None,
        }
    }
}

impl EvalContext {
    /// Apply a built-in geometric operation
    ///
    /// This is the bridge layer that makes RUNE expressions actually drive Hydron geometry.
    pub fn apply_builtin(&self, op: RuneBuiltin, args: &[Value]) -> Result<Value, EvalError> {
        match op {
            // Spherical S7 operations
            RuneBuiltin::S7Project => {
                let v = expect_vec8(args.first())?;
                let projected = SphericalLayer::project(&v);
                Ok(Value::Vec8(projected))
            }

            RuneBuiltin::S7Distance => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let dist = SphericalLayer::distance(&a, &b);
                Ok(Value::Scalar(dist))
            }

            RuneBuiltin::S7Slerp => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let t = expect_scalar(args.get(2))?;
                let result = SphericalLayer::slerp(&a, &b, t);
                Ok(Value::Vec8(result))
            }

            // Quaternion operations
            RuneBuiltin::QuatSlerp => {
                let a = expect_quat(args.first())?;
                let b = expect_quat(args.get(1))?;
                let t = expect_scalar(args.get(2))?;
                let result = QuaternionOps::slerp(&a, &b, t);
                Ok(Value::Quaternion(result))
            }

            // Symplectic operations
            RuneBuiltin::SymHamiltonian => {
                let state = expect_vec16(args.first())?;
                let (q, p) = split_phase_space(&state);
                let layer = SymplecticLayer::new();
                let h = layer.hamiltonian(&q, &p);
                Ok(Value::Scalar(h))
            }

            RuneBuiltin::SymEvolveStep => {
                let state = expect_vec16(args.first())?;
                let dt = expect_scalar(args.get(1))?;
                let (mut q, mut p) = split_phase_space(&state);
                let layer = SymplecticLayer::new();
                layer.evolve(&mut q, &mut p, dt);
                let evolved = merge_phase_space(&q, &p);
                Ok(Value::Vec16(evolved))
            }

            // Topological operations
            RuneBuiltin::TopoBetti => {
                let points = extract_point_cloud(args)?;
                let mut layer = TopologicalLayer::new();
                for point in points {
                    layer.add_point(point);
                }
                layer.compute_betti_numbers(2.0, 10); // max_radius=2.0, steps=10
                Ok(Value::Betti(layer.betti))
            }

            RuneBuiltin::TopoSignature => {
                let points = extract_point_cloud(args)?;
                let mut layer = TopologicalLayer::new();
                for point in points {
                    layer.add_point(point);
                }
                layer.compute_betti_numbers(2.0, 10);
                let sig = format!("β={:?}", layer.betti);
                Ok(Value::Symbol(sig))
            }

            // Gf8 core operations
            RuneBuiltin::Gf8Norm => {
                let v = expect_vec8(args.first())?;
                let norm = v.iter().map(|x| x * x).sum::<f32>().sqrt();
                Ok(Value::Scalar(norm))
            }

            RuneBuiltin::Gf8Normalize => {
                let v = expect_vec8(args.first())?;
                let norm = v.iter().map(|x| x * x).sum::<f32>().sqrt();
                if norm > 1e-10 {
                    let normalized = v.map(|x| x / norm);
                    Ok(Value::Vec8(normalized))
                } else {
                    Ok(Value::Vec8(v))
                }
            }

            RuneBuiltin::Gf8Dot => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let dot = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum::<f32>();
                Ok(Value::Scalar(dot))
            }

            // Spherical operations
            RuneBuiltin::S7Antipodal => {
                let v = expect_vec8(args.first())?;
                let antipodal = v.map(|x| -x);
                Ok(Value::Vec8(antipodal))
            }

            RuneBuiltin::S7Mean => {
                let points = extract_point_cloud(args)?;
                if points.is_empty() {
                    return Err(EvalError::InvalidOperation(
                        "Cannot compute mean of empty point cloud".to_string(),
                    ));
                }
                let result = SphericalLayer::mean(&points);
                Ok(Value::Vec8(result))
            }

            // Hyperbolic operations
            RuneBuiltin::H8Distance => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let dist = HyperbolicLayer::distance(&a, &b);
                Ok(Value::Scalar(dist))
            }

            RuneBuiltin::H8MobiusAdd => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let result = HyperbolicLayer::mobius_add(&a, &b);
                Ok(Value::Vec8(result))
            }

            // Fisher information geometry
            RuneBuiltin::FisherDistance => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let dist = a
                    .iter()
                    .zip(b.iter())
                    .map(|(x, y)| (x - y).powi(2))
                    .sum::<f32>()
                    .sqrt();
                Ok(Value::Scalar(dist))
            }

            RuneBuiltin::FisherMatrix => {
                let flat: Vec<Value> = (0..64)
                    .map(|i| {
                        let diag = if i / 8 == i % 8 { 1.0 } else { 0.0 };
                        Value::Scalar(diag)
                    })
                    .collect();
                Ok(Value::Array(flat))
            }

            RuneBuiltin::KLDivergence => {
                let p = expect_vec8(args.first())?;
                let q = expect_vec8(args.get(1))?;
                let kl = FisherLayer::kl_divergence(&p, &q);
                Ok(Value::Scalar(kl))
            }

            // Quaternion operations
            RuneBuiltin::QuatCompose => {
                let a = expect_quat(args.first())?;
                let b = expect_quat(args.get(1))?;
                // Quaternion multiplication: (a0,a)(b0,b) = (a0*b0 - a·b, a0*b + b0*a + a×b)
                let result = [
                    a[0] * b[0] - (a[1] * b[1] + a[2] * b[2] + a[3] * b[3]),
                    a[0] * b[1] + b[0] * a[1] + (a[2] * b[3] - a[3] * b[2]),
                    a[0] * b[2] + b[0] * a[2] + (a[3] * b[1] - a[1] * b[3]),
                    a[0] * b[3] + b[0] * a[3] + (a[1] * b[2] - a[2] * b[1]),
                ];
                Ok(Value::Quaternion(result))
            }

            RuneBuiltin::QuatConjugate => {
                let q = expect_quat(args.first())?;
                let conj = [q[0], -q[1], -q[2], -q[3]];
                Ok(Value::Quaternion(conj))
            }

            // Lorentzian operations
            RuneBuiltin::LorentzianCausal => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let interval = a[0].powi(2)
                    - a[1..]
                        .iter()
                        .zip(&b[1..])
                        .map(|(x, y)| (x - y).powi(2))
                        .sum::<f32>();
                Ok(Value::Bool(interval > 0.0))
            }

            RuneBuiltin::LorentzianDistance => {
                let a = expect_vec8(args.first())?;
                let b = expect_vec8(args.get(1))?;
                let dist = (a[0] - b[0]).powi(2)
                    - a[1..]
                        .iter()
                        .zip(&b[1..])
                        .map(|(x, y)| (x - y).powi(2))
                        .sum::<f32>();
                Ok(Value::Scalar(dist.abs().sqrt()))
            }

            // E8 graph helpers -------------------------------------------------
            RuneBuiltin::E8TypeI => {
                // Expect axes array of maps with at least "index" (0..7) and optional "weight"
                let axes_val = args.get(0).ok_or_else(|| {
                    EvalError::InvalidOperation("E8TypeI expects axes array".into())
                })?;
                let axes = parse_axes(axes_val)?;
                if axes.len() < 2 {
                    return Err(EvalError::InvalidOperation(
                        "E8TypeI requires at least two axes".into(),
                    ));
                }
                let mut verts = Vec::new();
                for a in 0..axes.len() {
                    for b in (a + 1)..axes.len() {
                        let (idx_a, w_a) = axes[a];
                        let (idx_b, w_b) = axes[b];
                        // four sign combinations
                        let signs = [(1.0, 1.0), (1.0, -1.0), (-1.0, 1.0), (-1.0, -1.0)];
                        for (sa, sb) in signs {
                            let mut v = [0.0f32; 8];
                            v[idx_a] = w_a * sa;
                            v[idx_b] = w_b * sb;
                            normalize_vec8(&mut v);
                            verts.push(Value::Vec8(v));
                        }
                    }
                }
                Ok(Value::Array(verts))
            }

            RuneBuiltin::E8TypeII => {
                let axes_val = args.get(0).ok_or_else(|| {
                    EvalError::InvalidOperation("E8TypeII expects axes array".into())
                })?;
                let axes = parse_axes(axes_val)?;
                if axes.len() != 8 {
                    return Err(EvalError::InvalidOperation(
                        "E8TypeII expects exactly 8 axes".into(),
                    ));
                }
                let mut verts = Vec::new();
                // 2^8 sign patterns, keep even number of negatives (128 spinors)
                for mask in 0u16..256 {
                    let negs = mask.count_ones();
                    if negs % 2 != 0 {
                        continue;
                    }
                    let mut v = [0.0f32; 8];
                    for (i, (idx, w)) in axes.iter().enumerate() {
                        let sign = if (mask & (1 << i)) != 0 { -0.5 } else { 0.5 };
                        v[*idx] = sign * *w;
                    }
                    normalize_vec8(&mut v);
                    verts.push(Value::Vec8(v));
                }
                Ok(Value::Array(verts))
            }

            RuneBuiltin::E8EdgesWhere => {
                // Args: vertices array (Vec8/Gf8), optional threshold (default 0.5), optional tolerance
                let verts_val = args.get(0).ok_or_else(|| {
                    EvalError::InvalidOperation("E8EdgesWhere expects vertices array".into())
                })?;
                let verts = parse_vec8_list(verts_val)?;
                let threshold = match args.get(1) {
                    Some(Value::Scalar(s)) => *s,
                    Some(Value::Float(f)) => *f as f32,
                    _ => 0.5f32,
                };
                let tol = match args.get(2) {
                    Some(Value::Scalar(s)) => s.abs(),
                    Some(Value::Float(f)) => (*f as f32).abs(),
                    _ => 1e-4f32,
                };
                let mut edges = Vec::new();
                for i in 0..verts.len() {
                    for j in (i + 1)..verts.len() {
                        let dot: f32 = verts[i]
                            .iter()
                            .zip(verts[j].iter())
                            .map(|(a, b)| a * b)
                            .sum();
                        if (dot - threshold).abs() <= tol {
                            let mut map = HashMap::new();
                            map.insert("u".to_string(), Value::Integer(i as i128));
                            map.insert("v".to_string(), Value::Integer(j as i128));
                            map.insert("strength".to_string(), Value::Scalar(dot));
                            map.insert("relationship".to_string(), Value::Symbol("Similar".into()));
                            edges.push(Value::Map(map));
                        }
                    }
                }
                Ok(Value::Array(edges))
            }

            RuneBuiltin::HexGraph => {
                // Accept tuple or array of three: (vertices, edges, axes)
                let pack = args.get(0).ok_or_else(|| {
                    EvalError::InvalidOperation("HexGraph expects (vertices, edges, axes)".into())
                })?;
                let (verts, edges, axes) = match pack {
                    Value::Tuple(v) if v.len() == 3 => (&v[0], &v[1], &v[2]),
                    Value::Array(v) if v.len() == 3 => (&v[0], &v[1], &v[2]),
                    _ => {
                        return Err(EvalError::InvalidOperation(
                            "HexGraph expects tuple/array of (vertices, edges, axes)".into(),
                        ));
                    }
                };
                let mut graph = HashMap::new();
                graph.insert("vertices".into(), verts.clone());
                graph.insert("edges".into(), edges.clone());
                graph.insert("axes".into(), axes.clone());
                graph.insert("domain_stats".into(), Value::Map(HashMap::new()));
                Ok(Value::Map(graph))
            }

            // Perception operations
            RuneBuiltin::Perceive => {
                let input = match args.first() {
                    Some(Value::String(s)) => s,
                    Some(Value::Symbol(s)) => s,
                    _ => return Err(EvalError::TypeMismatch("Perceive requires a string".into())),
                };

                let sig = crate::rune::hydron::perception::signal_encode(input.as_bytes());
                let morph = crate::rune::hydron::perception::morph_analyze(input);

                let v_sig = Value::Vec8(sig);
                let v_morph = Value::Vec8(morph);

                // Synthesis: Signal /\ Structure (Geometric Midpoint)
                v_sig.geometric_midpoint(&v_morph)
            }

            RuneBuiltin::CausalNow => {
                let layer = causal_layer();
                let guard = layer.lock().unwrap();
                let mut coords = [0.0f64; 8];
                coords[0] = guard.proper_time;
                Ok(Value::Spacetime(SpacetimePoint::new(coords)))
            }

            RuneBuiltin::CausalEmit => {
                if args.is_empty() {
                    return Err(EvalError::InvalidOperation(
                        "CausalEmit requires at least a payload".into(),
                    ));
                }
                let payload = args[0].clone();
                let mut idx = 1;
                let mut location: Option<SpacetimePoint> = None;
                let mut root: usize = 0;

                if let Some(arg1) = args.get(idx) {
                    if let Value::Spacetime(p) = arg1 {
                        location = Some(p.clone());
                        idx += 1;
                    } else if let Ok(r) = expect_scalar(Some(arg1)) {
                        root = r as usize;
                        idx += 1;
                    }
                }

                let causes: Vec<u64> = if let Some(cause_val) = args.get(idx) {
                    match cause_val {
                        Value::Array(arr) => {
                            let mut out = Vec::new();
                            for v in arr {
                                out.push(expect_id(v)?);
                            }
                            out
                        }
                        other => vec![expect_id(other)?],
                    }
                } else {
                    Vec::new()
                };

                let layer = causal_layer();
                let mut guard = layer.lock().unwrap();
                let id = guard.add_event(root, payload, &causes, location);
                Ok(Value::Integer(id as i128))
            }

            RuneBuiltin::CausalLink => {
                if args.len() < 2 {
                    return Err(EvalError::InvalidOperation(
                        "CausalLink requires cause and effect ids".into(),
                    ));
                }
                let cause = expect_id(&args[0])?;
                let effect = expect_id(&args[1])?;
                let layer = causal_layer();
                let mut guard = layer.lock().unwrap();
                guard
                    .add_link(cause, effect)
                    .map_err(|e| EvalError::InvalidOperation(e.to_string()))?;
                Ok(Value::Null)
            }

            RuneBuiltin::CausalConePast => {
                if args.is_empty() {
                    return Err(EvalError::InvalidOperation(
                        "CausalConePast requires an event id".into(),
                    ));
                }
                let id = expect_id(&args[0])?;
                let layer = causal_layer();
                let guard = layer.lock().unwrap();
                let cone = guard.past_light_cone(id);
                Ok(Value::Array(
                    cone.into_iter()
                        .map(|i| Value::Integer(i as i128))
                        .collect(),
                ))
            }

            RuneBuiltin::CausalConeFuture => {
                if args.is_empty() {
                    return Err(EvalError::InvalidOperation(
                        "CausalConeFuture requires an event id".into(),
                    ));
                }
                let id = expect_id(&args[0])?;
                let layer = causal_layer();
                let guard = layer.lock().unwrap();
                let cone = guard.future_light_cone(id);
                Ok(Value::Array(
                    cone.into_iter()
                        .map(|i| Value::Integer(i as i128))
                        .collect(),
                ))
            }

            RuneBuiltin::CausalVerify => {
                let layer = causal_layer();
                let guard = layer.lock().unwrap();
                Ok(Value::Bool(guard.verify_consistency()))
            }

            RuneBuiltin::FisherFilter => {
                if args.is_empty() {
                    return Err(EvalError::InvalidOperation(
                        "FisherFilter expects [values], optional threshold".into(),
                    ));
                }
                let list = match &args[0] {
                    Value::Array(arr) => arr,
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "FisherFilter first argument must be Array".into(),
                        ));
                    }
                };
                let threshold = args
                    .get(1)
                    .map(|v| expect_scalar(Some(v)))
                    .transpose()?
                    .unwrap_or(0.1);

                if list.is_empty() {
                    return Ok(Value::Array(Vec::new()));
                }

                let mut filtered = Vec::new();
                let mut prev_dist: Option<Vec<f32>> = None;
                for item in list.iter() {
                    let dist = value_to_distribution(item)?;
                    let keep = if let Some(prev) = &prev_dist {
                        let len = dist.len().min(prev.len());
                        let kl = FisherLayer::kl_divergence(&dist[..len], &prev[..len]);
                        kl > threshold
                    } else {
                        true
                    };
                    if keep {
                        filtered.push(item.clone());
                        prev_dist = Some(dist);
                    }
                }

                Ok(Value::Array(filtered))
            }

            RuneBuiltin::Fold => {
                if args.len() < 2 {
                    return Err(EvalError::InvalidOperation(
                        "Fold expects [values], operator".into(),
                    ));
                }
                let list = match &args[0] {
                    Value::Array(arr) => arr.clone(),
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Fold first argument must be Array".into(),
                        ));
                    }
                };
                let op_name = match &args[1] {
                    Value::Symbol(s) | Value::String(s) => s.clone(),
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Fold operator must be Symbol/String".into(),
                        ));
                    }
                };

                let mut iter = list.into_iter();
                let mut acc = match iter.next() {
                    Some(first) => first,
                    None => return Ok(args.get(2).cloned().unwrap_or(Value::Null)),
                };

                for item in iter {
                    acc = match op_name.as_str() {
                        "/\\" => acc.meet(&item)?,
                        "\\/" => acc.join(&item)?,
                        "\\|" => acc.reject(&item)?,
                        "|\\" => acc.project(&item)?,
                        _ => {
                            return Err(EvalError::InvalidOperation(format!(
                                "Unknown fold operator {}",
                                op_name
                            )));
                        }
                    };
                }
                Ok(acc)
            }

            RuneBuiltin::Filter => {
                if args.len() < 2 {
                    return Err(EvalError::InvalidOperation(
                        "Filter expects [values], pattern".into(),
                    ));
                }
                let list = match &args[0] {
                    Value::Array(arr) => arr,
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Filter first argument must be Array".into(),
                        ));
                    }
                };
                let pattern = &args[1];
                let mut out = Vec::new();
                for item in list {
                    if item.matches_pattern(pattern) {
                        out.push(item.clone());
                    }
                }
                Ok(Value::Array(out))
            }

            RuneBuiltin::AtlasNew => Ok(Value::Atlas(HashMap::new())),

            RuneBuiltin::AtlasInsert => {
                if args.len() < 3 {
                    return Err(EvalError::InvalidOperation(
                        "AtlasInsert expects [Atlas, Vector, Data]".into(),
                    ));
                }
                let mut atlas = args[0].clone();
                let key_vec = &args[1];
                let data = args[2].clone();
                atlas.atlas_insert(key_vec, data)?;
                Ok(atlas)
            }

            RuneBuiltin::AtlasRecall => {
                if args.len() < 2 {
                    return Err(EvalError::InvalidOperation(
                        "AtlasRecall expects [Atlas, Vector]".into(),
                    ));
                }
                let atlas = &args[0];
                let query = &args[1];
                atlas.atlas_recall(query)
            }

            RuneBuiltin::Neighbors => {
                let idx = match args.get(0) {
                    Some(Value::Integer(i)) => *i as usize,
                    Some(Value::Scalar(s)) => *s as usize,
                    Some(Value::Float(f)) => *f as usize,
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Neighbors expects a root index".into(),
                        ));
                    }
                };
                let neighbors = crate::rune::hydron::topology::get_neighbors(idx);
                let vals = neighbors
                    .into_iter()
                    .map(|i| Value::Integer(i as i128))
                    .collect();
                Ok(Value::Array(vals))
            }

            RuneBuiltin::Reflect => {
                let vec = expect_vec8(args.get(0))?;
                let mirror = expect_vec8(args.get(1))?;
                let reflected = crate::rune::hydron::topology::weyl_reflect(&vec, &mirror);
                Ok(Value::Vec8(reflected))
            }

            RuneBuiltin::Diffuse => {
                if args.len() < 2 {
                    return Err(EvalError::InvalidOperation(
                        "Diffuse expects [Array(240), rate]".into(),
                    ));
                }
                let energy = match &args[0] {
                    Value::Array(arr) => {
                        if arr.len() != 240 {
                            return Err(EvalError::TypeMismatch(
                                "Diffuse energy array must have length 240".into(),
                            ));
                        }
                        let mut out = [0.0f32; 240];
                        for (i, v) in arr.iter().enumerate() {
                            out[i] = match v {
                                Value::Scalar(s) => *s,
                                Value::Float(f) => *f as f32,
                                _ => {
                                    return Err(EvalError::TypeMismatch(
                                        "Diffuse energy entries must be numeric".into(),
                                    ));
                                }
                            };
                        }
                        out
                    }
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Diffuse first argument must be Array".into(),
                        ));
                    }
                };

                let rate = expect_scalar(args.get(1).map(|v| v))?;
                let diffused = crate::rune::hydron::topology::diffuse_energy(&energy, rate);
                let vals = diffused
                    .iter()
                    .map(|f| Value::Scalar(*f))
                    .collect::<Vec<_>>();
                Ok(Value::Array(vals))
            }

            // CUDA builtins - use CUDA accelerator if available
            RuneBuiltin::CudaDomR | RuneBuiltin::CudaArchetypeDomR => {
                #[cfg(feature = "cuda")]
                {
                    match crate::rune::hydron::cuda::get_cuda_accelerator().execute_domr("CudaDomR", args) {
                        Ok(result) => return Ok(result),
                        Err(_) => {
                            // Fall through to CPU implementation below
                        }
                    }
                }

                // CPU implementation fallback
                let energy_vec = expect_energy(args.get(0))?;
                let n_dr = match args.get(1) {
                    Some(Value::Integer(i)) => *i as usize,
                    Some(Value::Scalar(s)) => *s as usize,
                    Some(Value::Float(f)) => *f as usize,
                    _ => 8usize, // default
                };

                let graph = hex_model::default_graph();
                let domr = hex_model::domr_cpu(graph, &energy_vec, n_dr)
                    .map_err(|e| EvalError::InvalidOperation(e.to_string()))?;
                Ok(Value::DomR(domr))
            }

            RuneBuiltin::CudaVecDot => Err(EvalError::UnsupportedOperation("CudaVecDot not implemented".into())),

            RuneBuiltin::CudaTopK => Err(EvalError::UnsupportedOperation("CudaTopK not implemented".into())),
        }
    }

    /// Apply a builtin by string name; returns Err if unknown name.
    pub fn apply_builtin_by_name(&self, name: &str, args: &[Value]) -> Result<Value, EvalError> {
        if let Some(b) = RuneBuiltin::from_str(name) {
            self.apply_builtin(b, args)
        } else {
            Err(EvalError::InvalidOperation(format!(
                "Unknown builtin: {}",
                name
            )))
        }
    }
}

// ===================================
// Helper functions for type extraction
// ===================================

fn expect_vec8(val: Option<&Value>) -> Result<[f32; 8], EvalError> {
    match val {
        Some(Value::Vec8(v)) => Ok(*v),
        Some(Value::Array(arr)) => {
            // Ensure array has length 8 and extract floats
            if arr.len() != 8 {
                return Err(EvalError::TypeMismatch(format!(
                    "Expected Vec8 (array of 8 floats), got array length {}",
                    arr.len()
                )));
            }
            let mut v = [0.0f32; 8];
            for (i, elem) in arr.iter().enumerate() {
                match elem {
                    Value::Float(f) => v[i] = *f as f32,
                    Value::Scalar(s) => v[i] = *s,
                    _ => {
                        return Err(EvalError::TypeMismatch(format!(
                            "Expected numeric values for Vec8, found {:?}",
                            elem
                        )));
                    }
                }
            }
            Ok(v)
        }
        Some(other) => Err(EvalError::TypeMismatch(format!(
            "Expected Vec8, got {}",
            match other {
                Value::Scalar(_) => "Scalar",
                Value::Vec16(_) => "Vec16",
                Value::Quaternion(_) => "Quaternion",
                Value::Gf8(_) => "Gf8",
                Value::Octonion(_) => "Octonion",
                Value::Symbol(_) => "Symbol",
                Value::Matrix8x8(_) => "Matrix8x8",
                Value::Betti(_) => "Betti",
                _ => "unknown",
            }
        ))),
        None => Err(EvalError::InvalidOperation("Missing argument".to_string())),
    }
}

fn expect_vec16(val: Option<&Value>) -> Result<[f32; 16], EvalError> {
    match val {
        Some(Value::Vec16(v)) => Ok(*v),
        Some(_) => Err(EvalError::TypeMismatch("Expected Vec16".to_string())),
        None => Err(EvalError::InvalidOperation("Missing argument".to_string())),
    }
}

fn expect_quat(val: Option<&Value>) -> Result<[f32; 4], EvalError> {
    match val {
        Some(Value::Quaternion(q)) => Ok(*q),
        Some(_) => Err(EvalError::TypeMismatch("Expected Quaternion".to_string())),
        None => Err(EvalError::InvalidOperation("Missing argument".to_string())),
    }
}

fn expect_scalar(val: Option<&Value>) -> Result<f32, EvalError> {
    match val {
        Some(Value::Scalar(s)) => Ok(*s),
        Some(Value::Float(f)) => Ok(*f as f32),
        Some(_) => Err(EvalError::TypeMismatch(
            "Expected Scalar or Float".to_string(),
        )),
        None => Err(EvalError::InvalidOperation("Missing argument".to_string())),
    }
}

fn expect_id(val: &Value) -> Result<u64, EvalError> {
    match val {
        Value::Integer(i) => Ok(*i as u64),
        Value::Scalar(s) => Ok(*s as u64),
        Value::Float(f) => Ok(*f as u64),
        _ => Err(EvalError::TypeMismatch("Expected event id".to_string())),
    }
}

fn expect_energy(val: Option<&Value>) -> Result<Vec<f32>, EvalError> {
    let arr = match val {
        Some(Value::Array(arr)) => arr,
        Some(_) => {
            return Err(EvalError::TypeMismatch(
                "Energy must be an Array of 240 numeric values".into(),
            ));
        }
        None => {
            return Err(EvalError::InvalidOperation(
                "Missing energy argument".into(),
            ));
        }
    };
    if arr.len() != 240 {
        return Err(EvalError::TypeMismatch(format!(
            "Energy array must have length 240, got {}",
            arr.len()
        )));
    }
    let mut out = Vec::with_capacity(240);
    for v in arr {
        match v {
            Value::Scalar(s) => out.push(*s),
            Value::Float(f) => out.push(*f as f32),
            Value::Integer(i) => out.push(*i as f32),
            _ => {
                return Err(EvalError::TypeMismatch(
                    "Energy entries must be numeric".into(),
                ));
            }
        }
    }
    Ok(out)
}

fn value_to_distribution(val: &Value) -> Result<Vec<f32>, EvalError> {
    let mut dist = match val {
        Value::Array(arr) => {
            let mut out = Vec::with_capacity(arr.len());
            for v in arr {
                match v {
                    Value::Scalar(s) => out.push(*s),
                    Value::Float(f) => out.push(*f as f32),
                    _ => {
                        return Err(EvalError::TypeMismatch(
                            "Array must contain numeric values for FisherFilter".into(),
                        ));
                    }
                }
            }
            out
        }
        Value::Vec8(v) => v.to_vec(),
        Value::Vec16(v) => v.to_vec(),
        Value::Gf8(g) => g.coords().to_vec(),
        Value::Quaternion(q) => q.to_vec(),
        Value::Scalar(s) => vec![*s],
        Value::Float(f) => vec![*f as f32],
        _ => {
            return Err(EvalError::TypeMismatch(
                "Unsupported value for FisherFilter distribution".into(),
            ));
        }
    };

    let sum: f32 = dist.iter().map(|x| x.abs()).sum();
    if sum > 1e-8 {
        for x in dist.iter_mut() {
            *x /= sum;
        }
    }
    Ok(dist)
}

fn extract_point_cloud(args: &[Value]) -> Result<Vec<[f32; 8]>, EvalError> {
    // Handle multiple argument formats:
    // 1. Single PointCloud value
    // 2. Single Vec16 (two packed points)
    // 3. Multiple Vec8 arguments

    if args.is_empty() {
        return Err(EvalError::InvalidOperation(
            "No points provided".to_string(),
        ));
    }

    // Case 1: PointCloud value
    if args.len() == 1 {
        if let Value::PointCloud(points) = &args[0] {
            return Ok(points.clone());
        }

        // Case 2: Vec16 (two packed points)
        if let Value::Vec16(v16) = &args[0] {
            let p1 = [
                v16[0], v16[1], v16[2], v16[3], v16[4], v16[5], v16[6], v16[7],
            ];
            let p2 = [
                v16[8], v16[9], v16[10], v16[11], v16[12], v16[13], v16[14], v16[15],
            ];
            return Ok(vec![p1, p2]);
        }
    }

    // Case 3: Multiple Vec8 arguments
    let mut points = Vec::new();
    for arg in args {
        match arg {
            Value::Vec8(v) => points.push(*v),
            Value::PointCloud(pc) => points.extend_from_slice(pc),
            _ => {
                return Err(EvalError::TypeMismatch(
                    "Expected Vec8, Vec16, or PointCloud for point cloud".to_string(),
                ));
            }
        }
    }
    Ok(points)
}

/// Normalize a mutable Vec8 in-place; no-op for near-zero norm.
fn normalize_vec8(v: &mut [f32; 8]) {
    let norm_sq: f32 = v.iter().map(|x| x * x).sum();
    if norm_sq > 1e-9 {
        let inv = 1.0 / norm_sq.sqrt();
        for x in v {
            *x *= inv;
        }
    }
}

/// Extract axes as (index, weight) pairs from a Value::Array of maps.
fn parse_axes(val: &Value) -> Result<Vec<(usize, f32)>, EvalError> {
    let mut axes = Vec::new();
    let arr = match val {
        Value::Array(a) => a,
        _ => return Err(EvalError::TypeMismatch("Axes must be an array".into())),
    };
    for item in arr {
        match item {
            Value::Map(m) => {
                let idx_val = m
                    .get("index")
                    .ok_or_else(|| EvalError::TypeMismatch("Axis missing 'index' field".into()))?;
                let idx = expect_id(idx_val)? as usize;
                let w = match m.get("weight") {
                    Some(Value::Scalar(s)) => *s,
                    Some(Value::Float(f)) => *f as f32,
                    _ => 1.0,
                };
                axes.push((idx, w));
            }
            _ => return Err(EvalError::TypeMismatch("Axis must be a map".into())),
        }
    }
    // Deterministic ordering
    axes.sort_by_key(|(idx, _)| *idx);
    Ok(axes)
}

/// Parse a list of 8D vectors from various value representations.
fn parse_vec8_list(val: &Value) -> Result<Vec<[f32; 8]>, EvalError> {
    match val {
        Value::Array(arr) => {
            let mut out = Vec::with_capacity(arr.len());
            for v in arr {
                out.push(expect_vec8(Some(v))?);
            }
            Ok(out)
        }
        Value::PointCloud(points) => Ok(points.clone()),
        _ => Err(EvalError::TypeMismatch(
            "Expected Array of Vec8 for vertices".into(),
        )),
    }
}

/// Split Vec16 phase space into position and momentum
fn split_phase_space(state: &[f32; 16]) -> ([f32; 8], [f32; 8]) {
    let mut q = [0.0f32; 8];
    let mut p = [0.0f32; 8];
    q.copy_from_slice(&state[..8]);
    p.copy_from_slice(&state[8..]);
    (q, p)
}

/// Merge position and momentum into Vec16 phase space
fn merge_phase_space(q: &[f32; 8], p: &[f32; 8]) -> [f32; 16] {
    let mut state = [0.0f32; 16];
    state[..8].copy_from_slice(q);
    state[8..].copy_from_slice(p);
    state
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scalar_arithmetic() {
        let a = Value::Scalar(5.0);
        let b = Value::Scalar(3.0);

        assert_eq!(a.add(&b).unwrap(), Value::Scalar(8.0));
        assert_eq!(a.mul(&b).unwrap(), Value::Scalar(15.0));
        assert_eq!(a.sub(&b).unwrap(), Value::Scalar(2.0));
    }

    #[test]
    fn test_gf8_arithmetic() {
        use crate::rune::hydron::Gf8;

        // Test Gf8 addition (geometric addition on unit sphere)
        let gf_a = Gf8::new([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        let gf_b = Gf8::new([0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);

        let a = Value::Gf8(gf_a);
        let b = Value::Gf8(gf_b);

        // Geometric Gf8 addition
        let result = a.add(&b).unwrap();
        assert!(matches!(result, Value::Gf8(_)));
    }

    #[test]
    fn test_octonion_multiplication() {
        let a = Octonion::real(2.0);
        let b = Octonion::real(3.0);
        let c = a.mul(&b);

        assert_eq!(c.scalar, 6.0);
    }

    #[test]
    fn test_vec8_operations() {
        let a = Value::Vec8([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
        let b = Value::Vec8([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]);

        let result = a.add(&b).unwrap();
        if let Value::Vec8(v) = result {
            assert_eq!(v[0], 2.0);
            assert_eq!(v[7], 9.0);
        }
    }

    // ===================================
    // Integration Tests: RUNE → Hydron Geometry
    // ===================================

    #[test]
    fn test_rune_drives_spherical_geometry() {
        let ctx = EvalContext::new();

        // Test S7 projection
        let v = Value::Vec8([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        let result = ctx.apply_builtin(RuneBuiltin::S7Project, &[v]).unwrap();

        if let Value::Vec8(projected) = result {
            // Should be normalized to unit sphere
            let norm: f32 = projected.iter().map(|x| x * x).sum::<f32>().sqrt();
            assert!((norm - 1.0).abs() < 1e-6, "S7 projection should normalize");
        } else {
            panic!("Expected Vec8 result from S7Project");
        }

        // Test S7 distance
        let a = Value::Vec8([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        let b = Value::Vec8([0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        let dist = ctx
            .apply_builtin(RuneBuiltin::S7Distance, &[a.clone(), b.clone()])
            .unwrap();

        if let Value::Scalar(d) = dist {
            assert!(
                d > 0.0,
                "Distance between distinct points should be positive"
            );
        }

        // Test S7 slerp
        let t = Value::Scalar(0.5);
        let interp = ctx.apply_builtin(RuneBuiltin::S7Slerp, &[a, b, t]).unwrap();

        assert!(matches!(interp, Value::Vec8(_)), "Slerp should return Vec8");
    }

    #[test]
    fn test_rune_drives_symplectic_geometry() {
        let ctx = EvalContext::new();

        // Create a symplectic state (position + momentum)
        let state = Value::Vec16([
            1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // position
            0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // momentum
        ]);

        // Test Hamiltonian computation
        let h = ctx
            .apply_builtin(RuneBuiltin::SymHamiltonian, &[state.clone()])
            .unwrap();

        if let Value::Scalar(energy) = h {
            assert!(energy >= 0.0, "Hamiltonian should be non-negative");
        } else {
            panic!("Expected Scalar from SymHamiltonian");
        }

        // Test symplectic evolution
        let dt = Value::Scalar(0.1);
        let evolved = ctx
            .apply_builtin(RuneBuiltin::SymEvolveStep, &[state, dt])
            .unwrap();

        assert!(
            matches!(evolved, Value::Vec16(_)),
            "Symplectic evolution should return Vec16"
        );
    }

    #[test]
    fn test_rune_drives_topological_analysis() {
        let ctx = EvalContext::new();

        // Create a point cloud (2 points packed into Vec16)
        let points = Value::Vec16([
            1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // point 1
            0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // point 2
        ]);

        // Test Betti number computation
        let betti = ctx
            .apply_builtin(RuneBuiltin::TopoBetti, &[points.clone()])
            .unwrap();

        if let Value::Betti([b0, b1, b2]) = betti {
            assert!(b0 > 0, "Should have at least one connected component");
            // b1, b2 depend on point cloud structure
            let _ = (b1, b2);
        } else {
            panic!("Expected Betti from TopoBetti");
        }

        // Test topological signature
        let sig = ctx
            .apply_builtin(RuneBuiltin::TopoSignature, &[points])
            .unwrap();

        assert!(
            matches!(sig, Value::Symbol(_)),
            "Topological signature should return Symbol"
        );
    }

    #[test]
    fn test_from_trait_conversions() {
        // Test automatic Value wrapping
        let v8: Value = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0].into();
        assert!(matches!(v8, Value::Vec8(_)));

        let v16: Value = [0.0; 16].into();
        assert!(matches!(v16, Value::Vec16(_)));

        let quat: Value = [1.0, 0.0, 0.0, 0.0].into();
        assert!(matches!(quat, Value::Quaternion(_)));

        let betti: Value = [1, 0, 0].into();
        assert!(matches!(betti, Value::Betti(_)));
    }
}

File: parts\empty_and_root.rs
=============================
#[cfg(feature = "hydron")]
use crate::encode_default;
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn empty_and_root() {
    println!("Hydron feature required for dynamic empty and root");
}

#[cfg(feature = "hydron")]
pub fn empty_and_root() {
    // Dynamic Empty Container
    let empty_array = Value::Array(vec![]);
    let mut empty_map = HashMap::new();
    empty_map.insert("items".to_string(), empty_array);
    let empty_items = Value::Map(empty_map);
    println!("{}", encode_default(&empty_items).unwrap());

    // Dynamic Root Array
    let root_array = Value::Array(vec![
        Value::String("x".to_string()),
        Value::String("y".to_string()),
    ]);
    println!("\n{}", encode_default(&root_array).unwrap());

    // Dynamic Empty Object
    let empty_obj = Value::Map(HashMap::new());
    let out = encode_default(&empty_obj).unwrap();
    if out.is_empty() {
        println!("\n(empty output)");
    } else {
        println!("\n{out}");
    }
}

File: parts\mixed_arrays.rs
===========================
#[cfg(feature = "hydron")]
use crate::encode_default;
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn mixed_arrays() {
    println!("Hydron feature required for dynamic mixed arrays");
}

#[cfg(feature = "hydron")]
pub fn mixed_arrays() {
    // Dynamic Mixed Array
    let mut obj = HashMap::new();
    obj.insert("a".to_string(), Value::Integer(1));

    let mixed_array = Value::Array(vec![
        Value::Integer(1),
        Value::Map(obj),
        Value::String("text".to_string()),
    ]);

    let mut mixed_map = HashMap::new();
    mixed_map.insert("items".to_string(), mixed_array);
    let mixed = Value::Map(mixed_map);

    println!("{}", encode_default(&mixed).unwrap());

    // Dynamic List of Objects
    let mut item1 = HashMap::new();
    item1.insert("id".to_string(), Value::Integer(1));
    item1.insert("name".to_string(), Value::String("First".to_string()));

    let mut item2 = HashMap::new();
    item2.insert("id".to_string(), Value::Integer(2));
    item2.insert("name".to_string(), Value::String("Second".to_string()));
    item2.insert("extra".to_string(), Value::Bool(true));

    let list_array = Value::Array(vec![Value::Map(item1), Value::Map(item2)]);

    let mut list_map = HashMap::new();
    list_map.insert("items".to_string(), list_array);
    let list_objects = Value::Map(list_map);

    println!("\n{}", encode_default(&list_objects).unwrap());
}

File: parts\mod.rs
==================
pub mod arrays;
pub mod arrays_of_arrays;
pub mod decode_strict;
pub mod delimiters;
pub mod empty_and_root;
pub mod mixed_arrays;
pub mod objects;
pub mod round_trip;
pub mod structs;
pub mod tabular;

File: parts\round_trip.rs
=========================
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use crate::{decode_default, encode_default};
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn round_trip() {
    println!("Hydron feature required for dynamic round trip");
}

#[cfg(feature = "hydron")]
pub fn round_trip() {
    // Dynamic Round Trip (Value)
    let mut product_map = HashMap::new();
    product_map.insert("product".to_string(), Value::String("Widget".to_string()));
    product_map.insert("price".to_string(), Value::Float(29.99));
    product_map.insert("stock".to_string(), Value::Integer(100));

    let categories = Value::Array(vec![
        Value::String("tools".to_string()),
        Value::String("hardware".to_string()),
    ]);
    product_map.insert("categories".to_string(), categories);

    let original = Value::Map(product_map);

    let encoded = encode_default(&original).unwrap();
    let decoded: Value = decode_default(&encoded).unwrap();

    println!("Encoded:\n{encoded}",);
    println!("\nRound-trip equal: {}", original == decoded);
}

File: parts\objects.rs
======================
#[cfg(feature = "hydron")]
use crate::encode_default;
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn objects() {
    println!("Hydron feature required for dynamic objects");
}

#[cfg(feature = "hydron")]
pub fn objects() {
    // Dynamic Object: Simple
    let mut simple_map = HashMap::new();
    simple_map.insert("id".to_string(), Value::Integer(123));
    simple_map.insert("name".to_string(), Value::String("Ada".to_string()));
    simple_map.insert("active".to_string(), Value::Bool(true));
    let simple = Value::Map(simple_map);

    let out = encode_default(&simple).unwrap();
    println!("{out}");

    // Dynamic Object: Nested
    let mut user_info = HashMap::new();
    user_info.insert("id".to_string(), Value::Integer(123));
    user_info.insert("name".to_string(), Value::String("Ada".to_string()));

    let mut nested_map = HashMap::new();
    nested_map.insert("user".to_string(), Value::Map(user_info));
    let nested = Value::Map(nested_map);

    let out_nested = encode_default(&nested).unwrap();
    println!("\n{out_nested}");

    // Dynamic Array of Objects
    let mut user1 = HashMap::new();
    user1.insert("id".to_string(), Value::Integer(1));
    user1.insert("name".to_string(), Value::String("Alice".to_string()));
    user1.insert(
        "email".to_string(),
        Value::String("alice@example.com".to_string()),
    );
    user1.insert("active".to_string(), Value::Bool(true));

    let mut user2 = HashMap::new();
    user2.insert("id".to_string(), Value::Integer(2));
    user2.insert("name".to_string(), Value::String("Bob".to_string()));
    user2.insert(
        "email".to_string(),
        Value::String("bob@example.com".to_string()),
    );
    user2.insert("active".to_string(), Value::Bool(true));

    let users = Value::Array(vec![Value::Map(user1), Value::Map(user2)]);

    let out = encode_default(&users).unwrap();
    println!("\n{out}");
}

File: parts\structs.rs
======================
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use crate::{decode_default, encode_default};
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn serde_structs() {
    println!("Hydron feature required for dynamic structs");
}

#[cfg(feature = "hydron")]
pub fn serde_structs() {
    // Dynamic Struct (User)
    let mut user_map = HashMap::new();
    user_map.insert("name".to_string(), Value::String("Alice".to_string()));
    user_map.insert("age".to_string(), Value::Integer(30));
    user_map.insert(
        "email".to_string(),
        Value::String("alice@example.com".to_string()),
    );
    user_map.insert("active".to_string(), Value::Bool(true));
    let user = Value::Map(user_map);

    let toon = encode_default(&user).unwrap();
    println!("{toon}");

    let decoded: Value = decode_default(&toon).unwrap();
    assert_eq!(user, decoded);

    // Dynamic Nested Struct (Product)
    let mut metadata_map = HashMap::new();
    metadata_map.insert("category".to_string(), Value::String("Tech".to_string()));
    metadata_map.insert("in_stock".to_string(), Value::Bool(true));

    let tags = Value::Array(vec![
        Value::String("electronics".to_string()),
        Value::String("computers".to_string()),
    ]);

    let mut product_map = HashMap::new();
    product_map.insert("id".to_string(), Value::Integer(42));
    product_map.insert("name".to_string(), Value::String("Laptop".to_string()));
    product_map.insert("price".to_string(), Value::Float(999.99));
    product_map.insert("tags".to_string(), tags);
    product_map.insert("metadata".to_string(), Value::Map(metadata_map));
    let product = Value::Map(product_map);

    let toon = encode_default(&product).unwrap();
    println!("\n{toon}");

    let decoded: Value = decode_default(&toon).unwrap();
    assert_eq!(product, decoded);
}

File: parts\tabular.rs
======================
#[cfg(feature = "hydron")]
use crate::encode_default;
#[cfg(feature = "hydron")]
use crate::rune::hydron::values::Value;
#[cfg(feature = "hydron")]
use std::collections::HashMap;

#[cfg(not(feature = "hydron"))]
pub fn tabular() {
    println!("Hydron feature required for dynamic tabular data");
}

#[cfg(feature = "hydron")]
pub fn tabular() {
    // Dynamic Tabular Data
    let mut item1 = HashMap::new();
    item1.insert("sku".to_string(), Value::String("A1".to_string()));
    item1.insert("qty".to_string(), Value::Integer(2));
    item1.insert("price".to_string(), Value::Float(9.99));

    let mut item2 = HashMap::new();
    item2.insert("sku".to_string(), Value::String("B2".to_string()));
    item2.insert("qty".to_string(), Value::Integer(1));
    item2.insert("price".to_string(), Value::Float(14.5));

    let items_array = Value::Array(vec![Value::Map(item1), Value::Map(item2)]);

    let mut items_map = HashMap::new();
    items_map.insert("items".to_string(), items_array);
    let items = Value::Map(items_map);

    let out = encode_default(&items).unwrap();
    println!("{out}");

    // Dynamic Nested Tabular Data
    let mut user1 = HashMap::new();
    user1.insert("id".to_string(), Value::Integer(1));
    user1.insert("name".to_string(), Value::String("Ada".to_string()));

    let mut user2 = HashMap::new();
    user2.insert("id".to_string(), Value::Integer(2));
    user2.insert("name".to_string(), Value::String("Bob".to_string()));

    let users_array = Value::Array(vec![Value::Map(user1), Value::Map(user2)]);

    let mut container = HashMap::new();
    container.insert("users".to_string(), users_array);
    container.insert("status".to_string(), Value::String("active".to_string()));

    let items_array_nested = Value::Array(vec![Value::Map(container)]);

    let mut nested_map = HashMap::new();
    nested_map.insert("items".to_string(), items_array_nested);
    let nested = Value::Map(nested_map);

    let out_nested = encode_default(&nested).unwrap();
    println!("\n{out_nested}");
}

File: tests\archetype_integration.rs
====================================
//! Integration test for RUNE-ArchetypeEngine bridge
//!
//! Tests the end-to-end flow: RUNE kernel declaration -> ArchetypeEngine compilation -> PTX generation

use rune_format::rune::hydron::eval::Evaluator;
use rune_format::rune::parse;
use std::fs;
use std::path::Path;

#[cfg(feature = "cuda")]
#[test]
fn test_archetype_kernel_compilation() {
    // Define RUNE script with kernel declaration
    let script = r#"
Kernel:MyRowDot := CUDA:Archetype:RowDot(D: 8) and MyData -> MyRowDot
"#;

    // Parse the script
    let stmts = parse(script).expect("Failed to parse RUNE script");

    // Set up evaluator with initial data
    let mut eval = Evaluator::new();
    eval.set_var("MyData", rune_format::rune::hydron::values::Value::Array(vec![
        rune_format::rune::hydron::values::Value::Vec8([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]),
        rune_format::rune::hydron::values::Value::Vec8([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]),
    ]));

    // Evaluate the kernel declaration
    let result = eval.eval_stmt(&stmts[0]);
    assert!(result.is_ok(), "Kernel declaration evaluation failed");
    assert_eq!(result.unwrap(), rune_format::rune::hydron::values::Value::Null);

    // Check that PTX file was created
    let cache_dir = Path::new("target").join("rune").join("cache");
    assert!(cache_dir.exists(), "Cache directory should exist");

    // Find PTX files in cache directory
    let ptx_files: Vec<_> = fs::read_dir(&cache_dir)
        .expect("Failed to read cache directory")
        .filter_map(|entry| entry.ok())
        .map(|entry| entry.path())
        .filter(|path| path.extension().map_or(false, |ext| ext == "ptx"))
        .collect();

    assert!(!ptx_files.is_empty(), "At least one PTX file should be generated");
}

#[cfg(not(feature = "cuda"))]
#[test]
fn test_archetype_kernel_compilation_no_cuda() {
    // Define RUNE script with kernel declaration
    let script = r#"
Kernel:MyRowDot := CUDA:Archetype:RowDot(D: 8) and MyData -> MyRowDot
"#;

    // Parse the script
    let stmts = parse(script).expect("Failed to parse RUNE script");

    // Set up evaluator
    let mut eval = Evaluator::new();

    // Evaluate the kernel declaration - should fail without CUDA
    let result = eval.eval_stmt(&stmts[0]);
    assert!(result.is_err(), "Kernel declaration should fail without CUDA feature");

    if let Err(err) = result {
        assert!(err.to_string().contains("CUDA feature not enabled"));
    }
}
