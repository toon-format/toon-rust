File: src\lib.rs
================
/* src/lib.rs */
//!▫~•◦-------------------------------‣
//! # Core library module for rune-gate providing Bevy-based 3D visualization of E8-Life geometry.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gate to achieve comprehensive 3D visualization
//! and interaction with E8-Life geometric structures.
//!
//! ### Key Capabilities
//! - **Bevy ECS Integration:** Provides a complete Bevy plugin system for 3D rendering and UI.
//! - **E8 Geometry Visualization:** Renders complex 8-dimensional E8 root systems in 3D space.
//! - **Modular Architecture:** Organized into app, bridge, scene, and UI components for clean separation.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `app`, `bridge`, `scene`, and `ui`.
//! Result structures adhere to the Bevy ECS patterns and are compatible
//! with the system's rendering pipeline.
//!
//! ### Example
//! ```rust
//! use crate::rune_gate::{RuneGate, run_viewer_with_backend};
//!
//! // Launch the viewer with default backend
//! run_viewer_with_backend(HydronBackend::new());
//!
//! // Or use the plugin directly in your Bevy app
//! app.add_plugins(RuneGate);
//! ```
/*▫~•◦------------------------------------------------------------------------------------‣
 * © 2025 ArcMoon Studios ◦ SPDX-License-Identifier MIT OR Apache-2.0 ◦ Author: Lord Xyn ✶
 *///•------------------------------------------------------------------------------------‣

#[cfg(feature = "viewer")]
pub mod app;
pub mod bridge;
#[cfg(feature = "viewer")]
pub mod scene;
#[cfg(feature = "viewer")]
pub mod ui;

#[cfg(feature = "viewer")]
pub use app::{RuneGate, run_viewer_with_backend};
pub use bridge::{
    BackendHandle, DomainSummary, E8Backend, E8Query, HydronBackend, PathResult, QueryResult,
    SelectedVertex, VertexDetail,
};
#[cfg(feature = "viewer")]
pub use ui::{PanelSide, ViewerLayout};

File: src\bridge.rs
===================
/* src/bridge.rs */
//!▫~•◦-------------------------------‣
//! # Backend abstraction layer for E8 geometry data access and manipulation.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gate to provide a unified interface
//! between the Bevy frontend and E8 geometry backends.
//!
//! ### Key Capabilities
//! - **Backend Abstraction:** Defines the E8Backend trait for consistent data access across different implementations.
//! - **E8 Geometry Data:** Provides access to E8 root systems, vertices, and domain information.
//! - **Query Processing:** Supports geometric queries and path finding in E8 space.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `app` and `scene`.
//! The HydronBackend implementation connects to hydron-core for actual E8 geometry data.
//!
//! ### Example
//! ```rust
//! use crate::rune_gate::{E8Backend, HydronBackend, BackendHandle};
//!
//! let backend = HydronBackend::new();
//! let handle = BackendHandle::new(backend);
//! let domains = handle.0.list_domains();
//! let vertices = handle.0.list_vertices();
//! ```

#[cfg(feature = "viewer")]
use bevy::prelude::Resource;
use hydron_core::gf8::get_e8_roots;
use serde::{Deserialize, Serialize};

/// Trait that defines the contract between the Bevy frontend and the E8 backend.
pub trait E8Backend: Send + Sync + 'static {
    fn list_domains(&self) -> Vec<DomainSummary>;
    fn get_vertex(&self, id: u32) -> Option<VertexDetail>;
    fn list_vertices(&self) -> Vec<VertexDetail>;
    fn run_query(&self, query: E8Query) -> QueryResult;
    fn get_path(&self, from: u32, to: u32) -> PathResult;
}

/// Handle stored in Bevy world to access the injected backend.
#[cfg_attr(feature = "viewer", derive(Resource))]
pub struct BackendHandle(pub Box<dyn E8Backend>);

impl BackendHandle {
    pub fn new<B: E8Backend>(backend: B) -> Self {
        Self(Box::new(backend))
    }
}

/// Selected vertex resource shared between scene and UI.
#[cfg_attr(feature = "viewer", derive(Resource))]
#[derive(Default, Clone)]
pub struct SelectedVertex(pub Option<VertexDetail>);

/// Adapter that exposes the real Hydron data to the viewer.
/// For now this surfaces the canonical 240 E8 roots with minimal labeling.
#[derive(Clone, Default)]
pub struct HydronBackend;

impl HydronBackend {
    pub fn new() -> Self {
        Self
    }
}

impl E8Backend for HydronBackend {
    fn list_domains(&self) -> Vec<DomainSummary> {
        vec![
            DomainSummary {
                name: "E8 Root".into(),
                count: 112,
            },
            DomainSummary {
                name: "E8 Spinor".into(),
                count: 128,
            },
        ]
    }

    fn get_vertex(&self, id: u32) -> Option<VertexDetail> {
        self.list_vertices().into_iter().find(|v| v.id == id)
    }

    fn list_vertices(&self) -> Vec<VertexDetail> {
        let roots = get_e8_roots();
        roots
            .iter()
            .enumerate()
            .map(|(idx, coord)| {
                let kind = if idx < 112 { "TypeI" } else { "TypeII" };
                let domain = if idx < 112 { "E8 Root" } else { "E8 Spinor" };
                VertexDetail {
                    id: idx as u32,
                    label: format!("root-{idx:03}"),
                    domain: domain.into(),
                    kind: kind.into(),
                    coord8d: *coord,
                    blurb: "Canonical E8 basis element.".into(),
                    positive_color: None,
                    inverted_color: None,
                    opposite: None,
                }
            })
            .collect()
    }

    fn run_query(&self, _query: E8Query) -> QueryResult {
        QueryResult::Stub("Query execution not yet wired to hydron-core".into())
    }

    fn get_path(&self, from: u32, to: u32) -> PathResult {
        PathResult::Stub(format!("Path request from {from} to {to} not yet wired"))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainSummary {
    pub name: String,
    pub count: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VertexDetail {
    pub id: u32,
    pub label: String,
    pub domain: String,
    pub kind: String,
    pub coord8d: [f32; 8],
    pub blurb: String,
    pub positive_color: Option<String>,
    pub inverted_color: Option<String>,
    pub opposite: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct E8Query {
    pub text: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QueryResult {
    Stub(String),
    // Future: real results.
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PathResult {
    Stub(String),
    // Future: real path data.
}

File: src\scene.rs
==================
/* src/scene.rs */
//!▫~•◦-------------------------------‣
//! # 3D scene rendering and interaction system for E8 geometry visualization.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gate to provide comprehensive
//! 3D rendering, camera controls, and vertex interaction for E8-Life structures.
//!
//! ### Key Capabilities
//! - **3D Scene Management:** Sets up cameras, lighting, and renders E8 vertices as 3D spheres.
//! - **Interactive Controls:** Provides orbit camera controls with mouse and keyboard input.
//! - **Vertex Interaction:** Implements vertex picking, hovering, and selection with visual feedback.
//! - **8D to 3D Projection:** Projects 8-dimensional E8 coordinates into 3D space for visualization.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `bridge` and `ui`.
//! It uses Bevy's ECS architecture and integrates with the backend for vertex data.
//!
//! ### Example
//! ```rust
//! use crate::rune_gate::ScenePlugin;
//!
//! // Add the scene plugin to your Bevy app
//! app.add_plugins(ScenePlugin);
//!
//! // Access projection functionality
//! let projection = E8Projection::default();
//! let vec3d = projection.project(coord8d);
//! ```

use bevy::input::mouse::{MouseMotion, MouseWheel};
use bevy::math::primitives::Sphere;
use bevy::pbr::{MeshMaterial3d, StandardMaterial};
use bevy::prelude::*;
use bevy::render::alpha::AlphaMode;
use bevy::window::PrimaryWindow;

use crate::bridge::{BackendHandle, SelectedVertex, VertexDetail};

/// Plugin for the 3D scene (camera, lighting, nodes).
pub struct ScenePlugin;

impl Plugin for ScenePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, (setup_camera, setup_light, spawn_nodes))
            .add_systems(
                Update,
                (
                    orbit_camera_controls,
                    pick_vertices,
                    hover_vertices,
                    update_node_visuals,
                    focus_on_selection,
                ),
            );
    }
}

#[derive(Component)]
struct MainCamera;

fn setup_camera(mut commands: Commands) {
    commands.insert_resource(CameraRig::default());
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(0.0, 8.0, 18.0).looking_at(Vec3::ZERO, Vec3::Y),
        MainCamera,
    ));
}

fn setup_light(mut commands: Commands) {
    commands.spawn((
        PointLight {
            intensity: 2200.0,
            range: 120.0,
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(14.0, 22.0, 12.0),
    ));
}

/// Projection resource: simple linear map from 8D to 3D.
#[derive(Resource)]
pub struct E8Projection {
    pub mat_8x3: [[f32; 3]; 8],
}

fn palette_colors(v: &VertexDetail) -> (Color, Color) {
    if let (Some(p), Some(inv)) = (&v.positive_color, &v.inverted_color) {
        let base = hex_to_color(p).unwrap_or(Color::srgb(0.5, 0.7, 1.0));
        let halo = hex_to_color(inv).unwrap_or(base);
        return (base, halo);
    }
    match v.domain.as_str() {
        "Relationships" => (Color::srgb(0.25, 0.6, 0.9), Color::srgb(0.9, 0.4, 0.9)),
        "Psychology" => (Color::srgb(0.8, 0.6, 0.2), Color::srgb(0.2, 0.6, 0.9)),
        "E8 Root" => (Color::srgb(0.35, 0.8, 1.0), Color::srgb(0.2, 0.4, 1.0)),
        "E8 Spinor" => (Color::srgb(1.0, 0.45, 0.7), Color::srgb(0.8, 0.2, 0.6)),
        _ => (Color::srgb(0.75, 0.8, 0.85), Color::srgb(0.4, 0.5, 0.7)),
    }
}

fn hex_to_color(hex: &str) -> Option<Color> {
    let trimmed = hex.trim_start_matches('#');
    if trimmed.len() != 6 {
        return None;
    }
    let r = u8::from_str_radix(&trimmed[0..2], 16).ok()? as f32 / 255.0;
    let g = u8::from_str_radix(&trimmed[2..4], 16).ok()? as f32 / 255.0;
    let b = u8::from_str_radix(&trimmed[4..6], 16).ok()? as f32 / 255.0;
    Some(Color::srgb(r, g, b))
}

impl Default for E8Projection {
    fn default() -> Self {
        // Simple hand-picked projection
        Self {
            mat_8x3: [
                [1.0, 0.0, 0.0],
                [0.0, 1.0, 0.0],
                [0.0, 0.0, 1.0],
                [0.5, 0.2, 0.1],
                [0.1, 0.5, 0.2],
                [0.2, 0.1, 0.5],
                [0.3, 0.3, 0.1],
                [0.1, 0.3, 0.3],
            ],
        }
    }
}

impl E8Projection {
    pub fn project(&self, coord: [f32; 8]) -> Vec3 {
        let mut out = [0.0; 3];
        for i in 0..8 {
            out[0] += coord[i] * self.mat_8x3[i][0];
            out[1] += coord[i] * self.mat_8x3[i][1];
            out[2] += coord[i] * self.mat_8x3[i][2];
        }
        Vec3::new(out[0], out[1], out[2])
    }
}

#[derive(Component)]
pub struct SelectableVertex;

#[derive(Component, Clone)]
pub struct VertexData(pub VertexDetail);

#[derive(Component)]
pub struct VertexId(pub u32);

#[derive(Component)]
pub struct Halo(pub Handle<StandardMaterial>);

#[derive(Resource, Default, Clone)]
pub struct HoveredVertex(pub Option<VertexDetail>);

/// Simple orbital camera rig.
#[derive(Resource)]
struct CameraRig {
    target: Vec3,
    distance: f32,
    yaw: f32,
    pitch: f32,
}

impl Default for CameraRig {
    fn default() -> Self {
        Self {
            target: Vec3::ZERO,
            distance: 18.0,
            yaw: 0.0,
            pitch: -0.2,
        }
    }
}

fn spawn_nodes(
    mut commands: Commands,
    backend: Res<BackendHandle>,
    projection: Res<E8Projection>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let verts: Vec<VertexDetail> = backend.0.list_vertices();
    for v in verts {
        let pos = projection.project(v.coord8d);
        let (color, halo_color) = palette_colors(&v);
        let scale = if v.kind.contains("II") { 0.35 } else { 0.28 };

        let mesh = meshes.add(Sphere::new(scale).mesh().ico(3).unwrap());
        let material = materials.add(StandardMaterial {
            base_color: color,
            emissive: color.into(),
            metallic: 0.08,
            perceptual_roughness: 0.55,
            ..default()
        });
        let halo_material = materials.add(StandardMaterial {
            base_color: halo_color.with_alpha(0.2).into(),
            emissive: halo_color.into(),
            alpha_mode: AlphaMode::Add,
            unlit: true,
            ..default()
        });

        commands
            .spawn((
                Mesh3d(mesh.clone()),
                MeshMaterial3d(material),
                Transform::from_translation(pos),
                SelectableVertex,
                VertexData(v.clone()),
                VertexId(v.id),
            ))
            .with_children(|child| {
                child.spawn((
                    Mesh3d(mesh),
                    MeshMaterial3d(halo_material.clone()),
                    Transform::from_scale(Vec3::splat(1.1)),
                    Halo(halo_material.clone()),
                ));
            });
    }
}

fn orbit_camera_controls(
    time: Res<Time>,
    mut mouse_motion: MessageReader<MouseMotion>,
    mut mouse_wheel: MessageReader<MouseWheel>,
    buttons: Res<ButtonInput<MouseButton>>,
    mut rig: ResMut<CameraRig>,
    mut q_cam: Query<&mut Transform, With<MainCamera>>,
) {
    let mut look_delta = Vec2::ZERO;
    let mut pan_delta = Vec2::ZERO;

    for ev in mouse_motion.read() {
        if buttons.pressed(MouseButton::Right) {
            look_delta += ev.delta;
        } else if buttons.pressed(MouseButton::Middle) {
            pan_delta += ev.delta;
        }
    }

    // Orbit
    if look_delta.length_squared() > 0.0 {
        let sensitivity = 0.01;
        rig.yaw -= look_delta.x * sensitivity;
        rig.pitch = (rig.pitch - look_delta.y * sensitivity).clamp(-1.5, 1.5);
    }

    // Pan
    if pan_delta.length_squared() > 0.0 {
        if let Ok(transform) = q_cam.single() {
            let right = transform.right();
            let up = transform.up();
            let pan_speed = 0.002 * rig.distance.max(1.0);
            rig.target += (-pan_delta.x * pan_speed) * right + (pan_delta.y * pan_speed) * up;
        }
    }

    // Zoom
    for ev in mouse_wheel.read() {
        let zoom_speed = 6.0;
        rig.distance = (rig.distance - ev.y * zoom_speed * time.delta_secs()).clamp(3.0, 80.0);
    }

    // Apply to camera transform
    if let Ok(mut transform) = q_cam.single_mut() {
        let yaw_rot = Quat::from_rotation_y(rig.yaw);
        let pitch_rot = Quat::from_rotation_x(rig.pitch);
        let rotation = yaw_rot * pitch_rot;
        let offset = rotation * Vec3::new(0.0, 0.0, rig.distance);
        let eye = rig.target + offset;
        *transform = Transform::from_translation(eye).looking_at(rig.target, Vec3::Y);
    }
}

fn pick_vertices(
    buttons: Res<ButtonInput<MouseButton>>,
    windows: Query<&Window, With<PrimaryWindow>>,
    camera_q: Query<(&Camera, &GlobalTransform), With<MainCamera>>,
    verts: Query<(&GlobalTransform, &VertexData), With<SelectableVertex>>,
    mut selected: ResMut<SelectedVertex>,
) {
    if !buttons.just_pressed(MouseButton::Left) {
        return;
    }
    let window = if let Ok(w) = windows.single() {
        w
    } else {
        return;
    };
    let cursor = if let Some(pos) = window.cursor_position() {
        pos
    } else {
        return;
    };
    let (camera, cam_tf) = if let Ok(c) = camera_q.single() {
        c
    } else {
        return;
    };
    let Ok(ray) = camera.viewport_to_world(cam_tf, cursor) else {
        return;
    };

    let mut best: Option<(f32, VertexDetail)> = None;
    for (transform, data) in verts.iter() {
        let pos = transform.translation();
        let to_point = pos - ray.origin;
        let dir: Vec3 = ray.direction.into();
        let t = to_point.dot(dir);
        if t < 0.0 {
            continue;
        }
        let closest_point = ray.origin + dir * t;
        let dist_sq = pos.distance_squared(closest_point);
        let hit_radius_sq = 0.35f32 * 0.35;
        if dist_sq <= hit_radius_sq {
            if best.as_ref().map(|(d, _)| dist_sq < *d).unwrap_or(true) {
                best = Some((dist_sq, data.0.clone()));
            }
        }
    }

    if let Some((_, v)) = best {
        selected.0 = Some(v);
    }
}

fn hover_vertices(
    windows: Query<&Window, With<PrimaryWindow>>,
    camera_q: Query<(&Camera, &GlobalTransform), With<MainCamera>>,
    verts: Query<(&GlobalTransform, &VertexData), With<SelectableVertex>>,
    mut hovered: ResMut<HoveredVertex>,
) {
    let window = if let Ok(w) = windows.single() {
        w
    } else {
        return;
    };
    let cursor = if let Some(pos) = window.cursor_position() {
        pos
    } else {
        hovered.0 = None;
        return;
    };
    let (camera, cam_tf) = if let Ok(c) = camera_q.single() {
        c
    } else {
        hovered.0 = None;
        return;
    };
    let Ok(ray) = camera.viewport_to_world(cam_tf, cursor) else {
        hovered.0 = None;
        return;
    };

    let mut best: Option<(f32, VertexDetail)> = None;
    for (transform, data) in verts.iter() {
        let pos = transform.translation();
        let dir: Vec3 = ray.direction.into();
        let to_point = pos - ray.origin;
        let t = to_point.dot(dir);
        if t < 0.0 {
            continue;
        }
        let closest_point = ray.origin + dir * t;
        let dist_sq = pos.distance_squared(closest_point);
        let hit_radius_sq = 0.4f32 * 0.4;
        if dist_sq <= hit_radius_sq {
            if best.as_ref().map(|(d, _)| dist_sq < *d).unwrap_or(true) {
                best = Some((dist_sq, data.0.clone()));
            }
        }
    }
    hovered.0 = best.map(|(_, v)| v);
}

fn update_node_visuals(
    time: Res<Time>,
    selected: Res<SelectedVertex>,
    hovered: Res<HoveredVertex>,
    mut transforms: Query<(&mut Transform, Option<&Children>, &VertexData), With<SelectableVertex>>,
    mut halo_transforms: Query<&mut Transform, With<Halo>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    halos: Query<&Halo>,
) {
    let hover_id = hovered.0.as_ref().map(|v| v.id);
    let selected_id = selected.0.as_ref().map(|v| v.id);
    let pulse = (time.elapsed_secs() * 2.0).sin() * 0.5 + 0.5;

    for (mut transform, children, data) in transforms.iter_mut() {
        let mut scale = 1.0;
        if Some(data.0.id) == hover_id {
            scale *= 1.12;
        }
        if Some(data.0.id) == selected_id {
            scale *= 1.18;
        }
        transform.scale = Vec3::splat(scale);

        if let Some(children) = children {
            for child_entity in children.iter() {
                if let Ok(mut halo_tf) = halo_transforms.get_mut(child_entity) {
                    let mut halo_scale = 1.1;
                    let mut alpha = 0.2;
                    if Some(data.0.id) == hover_id {
                        halo_scale = 1.18;
                        alpha = 0.35;
                    }
                    if Some(data.0.id) == selected_id {
                        halo_scale = 1.2 + 0.08 * pulse;
                        alpha = 0.4 + 0.3 * pulse;
                    }
                    halo_tf.scale = Vec3::splat(halo_scale);
                    if let Ok(Halo(handle)) = halos.get(child_entity) {
                        if let Some(mat) = materials.get_mut(handle) {
                            mat.base_color = mat.base_color.with_alpha(alpha);
                            mat.emissive = mat.emissive.with_alpha(alpha);
                        }
                    }
                }
            }
        }
    }
}

fn focus_on_selection(
    projection: Res<E8Projection>,
    selected: Res<SelectedVertex>,
    mut rig: ResMut<CameraRig>,
) {
    if !selected.is_changed() {
        return;
    }
    if let Some(v) = &selected.0 {
        rig.target = projection.project(v.coord8d);
    }
}

File: Cargo.toml
================
[package]
name = "rune-gate"
version = "0.1.0"
edition = "2024"
publish = false
description = "Bevy-powered visual and runtime harness for RUNE E8 semantics"

[lib]
name = "rune_gate"
path = "src/lib.rs"

[[bin]]
name = "rune-gate"
path = "src/main.rs"

[features]
default = []
viewer = ["bevy"]

[dependencies]
yoshi = { workspace = true }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rune-format = { path = ".." }
rune-hex = { path = "../rune-hex" }
hydron-core = { path = "../hydron-core", features = ["serde"] }

# Bevy core; viewer is optional.
bevy = { version = "0.17.3", optional = true, features = [
    "bevy_asset",
    "bevy_winit",
    "bevy_render",
    "bevy_core_pipeline",
    "bevy_sprite",
    "bevy_text",
    "bevy_ui",
    "bevy_pbr",
    "png",
] }

# Ensure naga diagnostics compile with bevy's minimal default features.
naga = { version = "27.0.3", features = ["termcolor"] }

File: src\app.rs
================
/* src/app.rs */
//!▫~•◦-------------------------------‣
//! # Application entry point and plugin assembly for the rune-gate 3D viewer.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gate to provide the main application
//! structure and plugin coordination for E8-Life visualization.
//!
//! ### Key Capabilities
//! - **Bevy Application Setup:** Configures the main Bevy app with default plugins and window settings.
//! - **Plugin Assembly:** Coordinates the integration of scene, UI, and backend plugins.
//! - **Viewer Launching:** Provides convenience functions for launching the viewer with different backends.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `scene`, `ui`, and `bridge`.
//! It serves as the main entry point that assembles all the components into a cohesive application.
//!
//! ### Example
//! ```rust
//! use crate::rune_gate::{run_viewer, RuneGate};
//!
//! // Launch the viewer with default settings
//! run_viewer();
//!
//! // Or use the plugin in a custom Bevy app
//! app.add_plugins(RuneGate);
//! ```

use bevy::prelude::*;
use bevy::window::WindowResolution;

use crate::bridge::{BackendHandle, E8Backend, HydronBackend, SelectedVertex};
use crate::scene::{E8Projection, HoveredVertex, ScenePlugin};
use crate::ui::UiPlugin;

/// Marker plugin to assemble the viewer.
pub struct RuneGate;

impl Plugin for RuneGate {
    fn build(&self, app: &mut App) {
        if app.world_mut().get_resource::<BackendHandle>().is_none() {
            app.insert_resource(BackendHandle::new(HydronBackend::new()));
        }
        app.init_resource::<E8Projection>()
            .init_resource::<SelectedVertex>()
            .init_resource::<HoveredVertex>()
            .add_plugins(ScenePlugin)
            .add_plugins(UiPlugin);
    }
}

/// Launch the Bevy app with the default viewer stack.
pub fn run_viewer_with_backend<B: E8Backend>(backend: B) {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "rune-gate • E8-Life Viewer".into(),
                resolution: WindowResolution::new(1400, 900),
                ..default()
            }),
            ..default()
        }))
        .insert_resource(BackendHandle::new(backend))
        .add_plugins(RuneGate)
        .run();
}

/// Convenience launcher using the Hydron-backed implementation.
pub fn run_viewer() {
    run_viewer_with_backend(HydronBackend::new());
}

File: src\main.rs
=================
/* src/main.rs */
//!▫~•◦-------------------------------‣
//! # Main entry point for the rune-gate application with feature-based configuration.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gate to provide the executable
//! entry point with conditional compilation based on feature flags.
//!
//! ### Key Capabilities
//! - **Feature Detection:** Conditionally compiles based on the `viewer` feature flag.
//! - **Backend Integration:** Launches the viewer with the Hydron backend when enabled.
//! - **Graceful Degradation:** Provides informative error messages when features are missing.
//!
//! ### Architectural Notes
//! This module serves as the main entry point that delegates to the app module.
//! It works closely with the `app` module to provide the complete application experience.
//!
//! ### Example
//! ```rust
//! // When built with --features viewer, launches the full 3D viewer
//! cargo run --features viewer
//!
//! // Without the viewer feature, shows an informative message
//! cargo run
//! ```

#[cfg(feature = "viewer")]
fn main() {
    rune_gate::app::run_viewer_with_backend(rune_gate::HydronBackend::new());
}

#[cfg(not(feature = "viewer"))]
fn main() {
    eprintln!("rune-gate built without `viewer` feature; enable with --features viewer");
}

File: src\ui.rs
===============
/* src/ui.rs */
//!▫~•◦-------------------------------‣
//! # User interface system providing interactive panels and controls for the E8 viewer.
//!▫~•◦-------------------------------------------------------------------‣
//!
//! This module is designed for integration into rune-gate to provide a comprehensive
//! UI system with panel layouts, vertex details, and interactive controls.
//!
//! ### Key Capabilities
//! - **Panel System:** Configurable left/right panel layouts with toggle functionality.
//! - **Vertex Information:** Displays detailed information about selected E8 vertices and domains.
//! - **Interactive Controls:** Provides UI controls for layout toggling and vertex inspection.
//! - **Hover Tooltips:** Shows contextual information when hovering over 3D vertices.
//!
//! ### Architectural Notes
//! This module is designed to work with modules such as `bridge` and `scene`.
//! It uses Bevy's UI system and integrates with backend data for domain and vertex information.
//!
//! ### Example
//! ```rust
//! use crate::rune_gate::{UiPlugin, ViewerLayout, PanelSide};
//!
//! // Add the UI plugin to your Bevy app
//! app.add_plugins(UiPlugin);
//!
//! // Configure the layout
//! app.insert_resource(ViewerLayout {
//!     panel_side: PanelSide::Right,
//! });
//! ```

use bevy::prelude::*;
use bevy::window::PrimaryWindow;

use crate::bridge::{BackendHandle, DomainSummary, SelectedVertex};
use crate::scene::HoveredVertex;

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum PanelSide {
    Left,
    Right,
}

impl Default for PanelSide {
    fn default() -> Self {
        PanelSide::Left
    }
}

#[derive(Resource, Default)]
pub struct ViewerLayout {
    pub panel_side: PanelSide,
}

pub struct UiPlugin;

impl Plugin for UiPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<ViewerLayout>()
            .add_systems(Startup, setup_ui)
            .init_resource::<SelectedVertex>()
            .add_systems(
                Update,
                (
                    update_details_panel,
                    handle_layout_toggle,
                    update_hover_tooltip,
                ),
            );
    }
}

#[derive(Component)]
struct LayoutToggle;

#[derive(Component)]
struct LayoutToggleLabel;

#[derive(Component)]
struct RootUi;

fn setup_ui(mut commands: Commands, backend: Res<BackendHandle>, layout: Res<ViewerLayout>) {
    commands
        .spawn((
            Node {
                width: percent(100.0),
                height: percent(100.0),
                position_type: PositionType::Absolute,
                flex_direction: match layout.panel_side {
                    PanelSide::Left => FlexDirection::Row,
                    PanelSide::Right => FlexDirection::RowReverse,
                },
                ..default()
            },
            BackgroundColor(Color::NONE),
            RootUi,
        ))
        .with_children(|parent| {
            // Panel container
            parent
                .spawn((
                    Node {
                        width: percent(32.0),
                        height: percent(100.0),
                        flex_direction: FlexDirection::Row,
                        ..default()
                    },
                    BackgroundColor(Color::srgba(0.04, 0.05, 0.08, 0.95)),
                ))
                .with_children(|col| {
                    // Rail
                    col.spawn((
                        Node {
                            width: px(48.0),
                            height: percent(100.0),
                            flex_direction: FlexDirection::Column,
                            align_items: AlignItems::Center,
                            ..default()
                        },
                        BackgroundColor(Color::srgba(0.02, 0.03, 0.05, 0.95)),
                    ));

                    // Panel body
                    col.spawn((
                        Node {
                            width: percent(100.0),
                            height: percent(100.0),
                            flex_direction: FlexDirection::Column,
                            padding: UiRect::all(px(16.0)),
                            row_gap: px(12.0),
                            ..default()
                        },
                        BackgroundColor(Color::srgba(0.06, 0.07, 0.1, 0.9)),
                    ))
                    .with_children(|panel| {
                        // Layout toggle
                        panel
                            .spawn((
                                Button,
                                Node {
                                    width: px(140.0),
                                    height: px(32.0),
                                    justify_content: JustifyContent::Center,
                                    align_items: AlignItems::Center,
                                    ..default()
                                },
                                BackgroundColor(Color::srgba(0.08, 0.1, 0.16, 0.95)),
                                BorderRadius::all(px(4.0)),
                                LayoutToggle,
                            ))
                            .with_children(|btn| {
                                btn.spawn((
                                    Text::new(match layout.panel_side {
                                        PanelSide::Left => "Panel: Left (press L / click)",
                                        PanelSide::Right => "Panel: Right (press L / click)",
                                    }),
                                    TextFont::default(),
                                    TextColor(Color::srgb(0.75, 0.85, 1.0)),
                                    LayoutToggleLabel,
                                ));
                            });

                        // Graph panel header
                        panel.spawn((
                            Text::new("Graph"),
                            TextFont {
                                font_size: 20.0,
                                ..default()
                            },
                            TextColor(Color::srgb(0.75, 0.85, 1.0)),
                        ));

                        // Domains list
                        let domains: Vec<DomainSummary> = backend.0.list_domains();
                        for d in domains {
                            panel.spawn((
                                Text::new(format!("{}  ({})", d.name, d.count)),
                                TextFont {
                                    font_size: 14.0,
                                    ..default()
                                },
                                TextColor(Color::srgb(0.7, 0.8, 1.0)),
                            ));
                        }

                        // Query panel header
                        panel.spawn((
                            Text::new("Query"),
                            TextFont {
                                font_size: 20.0,
                                ..default()
                            },
                            TextColor(Color::srgb(0.75, 0.85, 1.0)),
                        ));
                        // Stub query buttons (visual only)
                        panel.spawn((
                            Text::new("Nearest to: courage (stub)"),
                            TextFont {
                                font_size: 14.0,
                                ..default()
                            },
                            TextColor(Color::srgb(0.6, 0.95, 0.9)),
                        ));
                        panel.spawn((
                            Text::new("Path: fear → resilience (stub)"),
                            TextFont {
                                font_size: 14.0,
                                ..default()
                            },
                            TextColor(Color::srgb(1.0, 0.6, 0.8)),
                        ));

                        // Details header
                        panel.spawn((
                            Text::new("Details"),
                            TextFont {
                                font_size: 20.0,
                                ..default()
                            },
                            TextColor(Color::srgb(0.75, 0.85, 1.0)),
                            DetailsHeader,
                        ));

                        // Details body
                        panel.spawn((
                            Text::new("Select a node…"),
                            TextFont {
                                font_size: 14.0,
                                ..default()
                            },
                            TextColor(Color::srgb(0.7, 0.8, 1.0)),
                            DetailsBody,
                        ));
                    });
                });

            // Scene placeholder (keeps flex layout balanced)
            parent.spawn((
                Node {
                    width: percent(68.0),
                    height: percent(100.0),
                    ..default()
                },
                BackgroundColor(Color::NONE),
            ));

            // Hover tooltip (initially hidden, absolute positioned)
            parent.spawn((
                Node {
                    position_type: PositionType::Absolute,
                    display: Display::None,
                    padding: UiRect::all(px(6.0)),
                    ..default()
                },
                BackgroundColor(Color::srgba(0.05, 0.06, 0.08, 0.9)),
                BorderRadius::all(px(6.0)),
                HoverTooltip,
                children![(
                    Text::new(""),
                    TextFont {
                        font_size: 12.0,
                        ..default()
                    },
                    TextColor(Color::srgb(0.85, 0.9, 1.0)),
                )],
            ));
        });
}

#[derive(Component)]
struct DetailsHeader;

#[derive(Component)]
struct DetailsBody;

#[derive(Component)]
struct HoverTooltip;

fn update_details_panel(
    selection: Option<Res<SelectedVertex>>,
    mut query: Query<(&mut Text, Option<&DetailsHeader>, Option<&DetailsBody>)>,
) {
    if selection.is_none() {
        return;
    }
    let sel = selection.unwrap();
    for (mut text, is_header, is_body) in query.iter_mut() {
        if is_header.is_some() {
            **text = "Details".into();
        } else if is_body.is_some() {
            **text = if let Some(v) = &sel.0 {
                format!(
                    "{}\nDomain: {}\nKind: {}\nID: {}\nBlurb: {}",
                    v.label, v.domain, v.kind, v.id, v.blurb
                )
            } else {
                "Select a node…".into()
            };
        }
    }
}

fn handle_layout_toggle(
    mut interactions: Query<&Interaction, (Changed<Interaction>, With<LayoutToggle>)>,
    mut layout: ResMut<ViewerLayout>,
    keys: Res<ButtonInput<KeyCode>>,
    mut roots: Query<&mut Node, With<RootUi>>,
    mut labels: Query<&mut Text, With<LayoutToggleLabel>>,
) {
    let mut flipped = false;
    for interaction in interactions.iter_mut() {
        if *interaction == Interaction::Pressed {
            flipped = true;
        }
    }
    if keys.just_pressed(KeyCode::KeyL) {
        flipped = true;
    }
    if !flipped {
        return;
    }
    layout.panel_side = match layout.panel_side {
        PanelSide::Left => PanelSide::Right,
        PanelSide::Right => PanelSide::Left,
    };

    for mut style in roots.iter_mut() {
        style.flex_direction = match layout.panel_side {
            PanelSide::Left => FlexDirection::Row,
            PanelSide::Right => FlexDirection::RowReverse,
        };
    }
    for mut text in labels.iter_mut() {
        **text = match layout.panel_side {
            PanelSide::Left => "Panel: Left (press L / click)".into(),
            PanelSide::Right => "Panel: Right (press L / click)".into(),
        };
    }
}

fn update_hover_tooltip(
    hovered: Option<Res<HoveredVertex>>,
    window_q: Query<&Window, With<PrimaryWindow>>,
    mut tooltip_q: Query<(&mut Node, &mut Text), With<HoverTooltip>>,
    mouse_buttons: Res<ButtonInput<MouseButton>>,
) {
    let Some(hovered) = hovered else { return };
    let Ok(window) = window_q.single() else {
        return;
    };
    let Ok((mut node, mut text)) = tooltip_q.single_mut() else {
        return;
    };

    if let Some(cursor) = window.cursor_position() {
        if let Some(v) = &hovered.0 {
            node.display = Display::Flex;
            node.left = px(cursor.x + 14.0);
            node.top = px(cursor.y + 14.0);
            let opp = v
                .opposite
                .as_ref()
                .map(|o| format!("Opposite: {}", o))
                .unwrap_or_else(|| "".into());
            **text = format!("{}\n{} • {}\n{}", v.label, v.domain, v.kind, opp)
                .trim()
                .to_string();
        } else {
            node.display = Display::None;
        }
    } else {
        node.display = Display::None;
    }

    // Hide tooltip while dragging/orbiting with right/middle buttons
    if mouse_buttons.pressed(MouseButton::Right) || mouse_buttons.pressed(MouseButton::Middle) {
        node.display = Display::None;
    }
}
